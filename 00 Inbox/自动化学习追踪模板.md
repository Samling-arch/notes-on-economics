<%*
// ====================================
// ğŸ¤– è‡ªåŠ¨åŒ–å­¦ä¹ è¿½è¸ªç³»ç»Ÿ  
// ä½¿ç”¨æ–¹æ³•: åœ¨Templaterä¸­è°ƒç”¨æ­¤æ¨¡æ¿
// ====================================

class AutoLearningTracker {
    constructor() {
        this.app = app;
        this.tp = tp;
        this.currentFile = this.tp.file.find_tfile(this.tp.file.title);
    }

    // è·å–å½“å‰æ–‡ä»¶çš„å­¦ä¹ æ•°æ®
    async getCurrentFileData() {
        if (!this.currentFile) return null;
        
        try {
            const content = await this.app.vault.read(this.currentFile);
            const frontmatter = this.app.metadataCache.getFileCache(this.currentFile)?.frontmatter || {};
            
            return {
                title: this.currentFile.basename,
                path: this.currentFile.path,
                size: content.length,
                wordCount: content.split(/\s+/).filter(word => word.length > 0).length,
                content: content,
                frontmatter: frontmatter
            };
        } catch (error) {
            console.warn('è·å–æ–‡ä»¶æ•°æ®å¤±è´¥:', error);
            return null;
        }
    }

    // æ£€æµ‹å­¦ä¹ æ¨¡å¼
    detectLearningPattern(data) {
        if (!data) return "æœªçŸ¥æ¨¡å¼";
        
        const editTime = data.frontmatter.edit_duration || 0;
        const wordCount = data.wordCount || 0;
        const hasImages = data.content?.includes('![') || false;
        
        if (editTime > 1800 && wordCount > 500) {
            return "æ·±åº¦å­¦ä¹ ";
        } else if (editTime > 600 && hasImages) {
            return "èµ„æ–™æ•´ç†";  
        } else if (editTime > 300) {
            return "çŸ¥è¯†è®°å½•";
        } else {
            return "å¿«é€Ÿæµè§ˆ";
        }
    }

    // è®¡ç®—å­¦ä¹ è¿›åº¦
    calculateProgress(subject) {
        if (!subject) return 0;
        
        try {
            const notes = this.app.vault.getMarkdownFiles()
                .filter(file => file.path.includes(subject));
            
            if (notes.length === 0) return 0;
            
            let totalProgress = 0;
            let validNotes = 0;
            
            notes.forEach(note => {
                try {
                    const cache = this.app.metadataCache.getFileCache(note);
                    const progress = cache?.frontmatter?.progress;
                    
                    let progressNum = 0;
                    if (typeof progress === 'string' && progress.includes('%')) {
                        progressNum = parseInt(progress.replace('%', ''));
                    } else if (typeof progress === 'number') {
                        progressNum = progress;
                    }
                    
                    if (progressNum > 0) {
                        totalProgress += progressNum;
                        validNotes++;
                    }
                } catch (error) {
                    console.warn('å¤„ç†ç¬”è®°è¿›åº¦å¤±è´¥:', note.path, error);
                }
            });
            
            return validNotes > 0 ? Math.round(totalProgress / validNotes) : 0;
        } catch (error) {
            console.warn('è®¡ç®—è¿›åº¦å¤±è´¥:', error);
            return 0;
        }
    }

    // è‡ªåŠ¨æ›´æ–°å­¦ä¹ ç»Ÿè®¡
    async updateLearningStats() {
        const data = await this.getCurrentFileData();
        if (!data) return null;

        const subject = this.detectSubject(data.path);
        
        const stats = {
            last_studied: new Date().toISOString().split('T')[0],
            study_pattern: this.detectLearningPattern(data),
            word_count: data.wordCount,
            file_size: data.size,
            subject: subject,
            auto_updated: true
        };

        if (!data.frontmatter.progress && subject) {
            const calculatedProgress = this.calculateProgress(subject);
            if (calculatedProgress > 0) {
                stats.progress = calculatedProgress;
            }
        }

        return stats;
    }

    // æ£€æµ‹ç§‘ç›®åç§°
    detectSubject(filePath) {
        if (!filePath) return null;
        
        const subjectMap = {
            'L4è´¢åŠ¡ç®¡ç†å­¦': 'è´¢åŠ¡ç®¡ç†å­¦',
            'L5 æŠ•èµ„å­¦': 'æŠ•èµ„å­¦', 
            'LæŠ•èµ„å­¦': 'æŠ•èµ„å­¦',
            'L7ç»Ÿè®¡å­¦': 'ç»Ÿè®¡å­¦',
            'L_ç»æµæ³•': 'ç»æµæ³•',
            'L2_åˆ¶åº¦ç»æµå­¦': 'åˆ¶åº¦ç»æµå­¦',
            'L6è´¢æ”¿å­¦': 'è´¢æ”¿å­¦',
            'L3æ¯›æ¦‚': 'æ¯›æ¦‚',
            'å¤§äºŒä¸‹': 'å¤§äºŒä¸‹è¯¾ç¨‹',
            'å¤§ä¸‰ä¸Š': 'å¤§ä¸‰ä¸Šè¯¾ç¨‹'
        };

        for (const [key, value] of Object.entries(subjectMap)) {
            if (filePath.includes(key)) {
                return value;
            }
        }
        return null;
    }

    // ç”Ÿæˆå­¦ä¹ æ´å¯Ÿ
    generateInsights() {
        const insights = [];
        
        try {
            const todayFiles = this.getTodayStudiedFiles();
            if (todayFiles.length > 0) {
                insights.push(`ğŸ“š ä»Šæ—¥å·²å­¦ä¹  ${todayFiles.length} ä¸ªæ–‡ä»¶`);
            }

            const streak = this.getStudyStreak();
            if (streak > 1) {
                insights.push(`ğŸ”¥ å·²è¿ç»­å­¦ä¹  ${streak} å¤©`);
            }

            const mostActive = this.getMostActiveSubject();
            if (mostActive) {
                insights.push(`â­ æœ€æ´»è·ƒç§‘ç›®: ${mostActive}`);
            }
            
            if (insights.length === 0) {
                insights.push(`ğŸ“ å¼€å§‹æ–°çš„å­¦ä¹ è®°å½•`);
            }
        } catch (error) {
            console.warn('ç”Ÿæˆæ´å¯Ÿå¤±è´¥:', error);
            insights.push(`âš ï¸ æ´å¯Ÿç”Ÿæˆå¼‚å¸¸ï¼Œè¯·æ£€æŸ¥æ•°æ®`);
        }

        return insights;
    }

    // è·å–ä»Šæ—¥å­¦ä¹ çš„æ–‡ä»¶
    getTodayStudiedFiles() {
        try {
            const today = new Date().toISOString().split('T')[0];
            return this.app.vault.getMarkdownFiles()
                .filter(file => {
                    try {
                        const cache = this.app.metadataCache.getFileCache(file);
                        const lastStudied = cache?.frontmatter?.last_studied;
                        return lastStudied === today;
                    } catch (error) {
                        return false;
                    }
                });
        } catch (error) {
            console.warn('è·å–ä»Šæ—¥æ–‡ä»¶å¤±è´¥:', error);
            return [];
        }
    }

    // è®¡ç®—å­¦ä¹ è¿å‡»å¤©æ•°
    getStudyStreak() {
        try {
            const files = this.app.vault.getMarkdownFiles();
            const studyDates = new Set();
            
            files.forEach(file => {
                try {
                    const cache = this.app.metadataCache.getFileCache(file);
                    const lastStudied = cache?.frontmatter?.last_studied;
                    if (lastStudied && typeof lastStudied === 'string') {
                        studyDates.add(lastStudied);
                    }
                } catch (error) {
                    // å¿½ç•¥å•ä¸ªæ–‡ä»¶çš„é”™è¯¯
                }
            });

            const sortedDates = Array.from(studyDates).sort().reverse();
            let streak = 0;
            
            for (let i = 0; i < sortedDates.length; i++) {
                const expectedDate = new Date();
                expectedDate.setDate(expectedDate.getDate() - i);
                const expectedDateStr = expectedDate.toISOString().split('T')[0];
                
                if (sortedDates[i] === expectedDateStr) {
                    streak++;
                } else {
                    break;
                }
            }
            
            return streak;
        } catch (error) {
            console.warn('è®¡ç®—è¿å‡»å¤±è´¥:', error);
            return 0;
        }
    }

    // è·å–æœ€æ´»è·ƒçš„ç§‘ç›®
    getMostActiveSubject() {
        try {
            const subjectStats = {};
            const files = this.app.vault.getMarkdownFiles();
            
            files.forEach(file => {
                try {
                    const cache = this.app.metadataCache.getFileCache(file);
                    const subject = cache?.frontmatter?.subject;
                    const lastStudied = cache?.frontmatter?.last_studied;
                    
                    if (subject && lastStudied) {
                        const weekAgo = new Date();
                        weekAgo.setDate(weekAgo.getDate() - 7);
                        const studyDate = new Date(lastStudied);
                        
                        if (studyDate >= weekAgo) {
                            subjectStats[subject] = (subjectStats[subject] || 0) + 1;
                        }
                    }
                } catch (error) {
                    // å¿½ç•¥å•ä¸ªæ–‡ä»¶çš„é”™è¯¯
                }
            });

            let mostActive = null;
            let maxCount = 0;
            
            for (const [subject, count] of Object.entries(subjectStats)) {
                if (count > maxCount) {
                    maxCount = count;
                    mostActive = subject;
                }
            }
            
            return mostActive;
        } catch (error) {
            console.warn('è·å–æœ€æ´»è·ƒç§‘ç›®å¤±è´¥:', error);
            return null;
        }
    }

    // ä¸»æ‰§è¡Œå‡½æ•°
    async execute() {
        try {
            const stats = await this.updateLearningStats();
            const insights = this.generateInsights();
            
            return {
                stats: stats,
                insights: insights,
                timestamp: new Date().toLocaleString('zh-CN'),
                success: true
            };
            
        } catch (error) {
            console.error('è‡ªåŠ¨åŒ–è¿½è¸ªé”™è¯¯:', error);
            return {
                error: error.message,
                timestamp: new Date().toLocaleString('zh-CN'),
                success: false
            };
        }
    }
}

// æ‰§è¡Œè‡ªåŠ¨åŒ–è¿½è¸ª
try {
    const tracker = new AutoLearningTracker();
    const result = await tracker.execute();

    // è¾“å‡ºç»“æœåˆ°æ¨¡æ¿
    if (result.error || !result.success) {
        tR += `âš ï¸ è‡ªåŠ¨åŒ–è¿½è¸ªå‡ºé”™: ${result.error || 'æœªçŸ¥é”™è¯¯'}\n`;
        tR += `*é”™è¯¯æ—¶é—´: ${result.timestamp}*\n`;
    } else {
        // è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        if (result.stats) {
            tR += `## ğŸ¤– è‡ªåŠ¨å­¦ä¹ ç»Ÿè®¡\n\n`;
            tR += `- **æœ€åå­¦ä¹ **: ${result.stats.last_studied}\n`;
            tR += `- **å­¦ä¹ æ¨¡å¼**: ${result.stats.study_pattern}\n`;
            tR += `- **å­—æ•°ç»Ÿè®¡**: ${result.stats.word_count.toLocaleString()}\n`;
            
            if (result.stats.subject) {
                tR += `- **ç§‘ç›®**: ${result.stats.subject}\n`;
            }
            
            if (result.stats.progress) {
                tR += `- **è‡ªåŠ¨è¿›åº¦**: ${result.stats.progress}%\n`;
            }
            
            tR += `\n`;
        }
        
        // è¾“å‡ºæ´å¯Ÿä¿¡æ¯
        if (result.insights && result.insights.length > 0) {
            tR += `## ğŸ’¡ å­¦ä¹ æ´å¯Ÿ\n\n`;
            result.insights.forEach(insight => {
                tR += `- ${insight}\n`;
            });
            tR += `\n`;
        }
        
        tR += `*è‡ªåŠ¨æ›´æ–°æ—¶é—´: ${result.timestamp}*\n`;
    }
} catch (globalError) {
    tR += `ğŸš¨ è„šæœ¬æ‰§è¡Œå¤±è´¥: ${globalError.message}\n`;
    tR += `*å¤±è´¥æ—¶é—´: ${new Date().toLocaleString('zh-CN')}*\n`;
}
%> 