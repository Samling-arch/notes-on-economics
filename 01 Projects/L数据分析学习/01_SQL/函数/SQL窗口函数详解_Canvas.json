{
  "nodes": [
    {
      "id": "title",
      "type": "text",
      "x": 400,
      "y": -100,
      "width": 800,
      "height": 150,
      "color": "1",
      "text": "# SQL高级应用：窗口函数详解\n\n**拉勾教育数据分析训练营** | 经典老师 | 2021-05-18\n\n> **通俗理解**：窗口函数就像一个会移动的放大镜，帮我们在数据表中圈定不同的\"观察窗口\"来做复杂统计\n\n[视频链接](https://www.bilibili.com/video/av205732110/)"
    },
    {
      "id": "overview",
      "type": "text",
      "x": 50,
      "y": 100,
      "width": 350,
      "height": 280,
      "color": "4",
      "text": "## 课程整体架构\n\n### MySQL 8.0+ 高级应用三大板块\n\n**1. 窗口函数（分析函数）** ⭐\n- 解决复杂报表统计分析场景\n- MySQL 8.0版本才开始支持\n- 以前商业数据库早就支持了\n\n**2. 索引**\n- 提升查询性能\n- 优化数据检索速度\n\n**3. 视图**\n- 简化复杂查询\n- 数据安全和抽象\n\n> **通俗理解**：就像学开车要先学理论、再学操作、最后学维护，这三块是MySQL进阶的必备技能"
    },
    {
      "id": "window_concept",
      "type": "text",
      "x": 450,
      "y": 100,
      "width": 400,
      "height": 350,
      "color": "2",
      "text": "## 什么是窗口函数？\n\n### 核心概念分解\n\n**窗口函数 = 窗口 + 函数**\n\n#### 🪟 窗口（Window）\n- 类似于\"窗户\"，限定了一个空间范围\n- 在数据库中指**记录的集合**\n- 动态变化的数据观察范围\n\n#### 🔧 函数（Function）  \n- 应用在窗口内的特殊函数\n- 如：SUM、COUNT、AVG等\n\n### 📊 与普通聚合函数的区别\n\n| 类型 | 输入 | 输出 | 特点 |\n|------|------|------|------|\n| 普通聚合 | 多行 | 1行 | 分组后只返回一个结果 |\n| 窗口函数 | 多行 | 多行 | **每一行都有结果** |\n\n> **通俗理解**：普通聚合函数像是把一堆苹果榨成一杯果汁，窗口函数像是给每个苹果都贴上营养标签"
    },
    {
      "id": "real_example",
      "type": "text",
      "x": 900,
      "y": 100,
      "width": 450,
      "height": 400,
      "color": "3",
      "text": "## 📈 实际业务场景示例\n\n### 销售数据累计统计需求\n\n```sql\n-- 原始数据表结构\nCREATE TABLE sales (\n    month_date DATE,     -- 日期字段\n    sales_amount INT     -- 销售额字段\n);\n```\n\n| 日期 | 当月销售额 | 📍需求：累计销售额 |\n|------|------------|--------------------|\n| 2019-01 | $1000 | $1000 |\n| 2019-02 | $2000 | $3000 |\n| 2019-03 | $3000 | $6000 |\n| 2019-04 | $4000 | $10000 |\n| 2019-05 | $5000 | $15000 |\n| 2019-06 | $6000 | $21000 |\n\n### 🎯 业务需求分析\n- **目标**：每行都显示\"本年度累计销售额\"\n- **难点**：传统SQL很难实现\n- **解决方案**：窗口函数轻松搞定！\n\n> **通俗理解**：就像跑马拉松，不仅要知道这一圈跑了多少，还要知道总共跑了多少公里"
    },
    {
      "id": "window_mechanism",
      "type": "text",
      "x": 100,
      "y": 550,
      "width": 500,
      "height": 380,
      "color": "5",
      "text": "## 🔍 窗口工作机制详解\n\n### 动态窗口变化过程\n\n#### 第1条记录执行时：\n```\n┌─────────────────┐\n│ 2019-01 | $1000 │ ← 当前窗口\n└─────────────────┘\n累计销售额 = $1000\n```\n\n#### 第2条记录执行时：\n```\n┌─────────────────┐\n│ 2019-01 | $1000 │\n│ 2019-02 | $2000 │ ← 窗口扩大\n└─────────────────┘\n累计销售额 = $1000 + $2000 = $3000\n```\n\n#### 第3条记录执行时：\n```\n┌─────────────────┐\n│ 2019-01 | $1000 │\n│ 2019-02 | $2000 │\n│ 2019-03 | $3000 │ ← 窗口继续扩大\n└─────────────────┘\n累计销售额 = $1000 + $2000 + $3000 = $6000\n```\n\n### 🎯 关键特点\n- 每条记录都会在**此窗口内执行函数**\n- 窗口大小**动态变化**\n- 每一行都有**独立的计算结果**\n\n> **通俗理解**：像用不同大小的放大镜观察数据，镜片越来越大，看到的数据越来越多"
    },
    {
      "id": "basic_syntax",
      "type": "text",
      "x": 650,
      "y": 550,
      "width": 450,
      "height": 350,
      "color": "6",
      "text": "## 📝 窗口函数基本语法\n\n### 完整语法结构\n\n```sql\n函数名(参数) OVER (\n    PARTITION BY 分组字段\n    ORDER BY 排序字段  \n    ROWS BETWEEN 开始行 AND 结束行\n)\n```\n\n### 🧩 语法组件解析\n\n#### 1️⃣ **函数部分**\n- `SUM()` - 求和\n- `COUNT()` - 计数  \n- `AVG()` - 平均值\n- `MAX()`, `MIN()` - 最值\n\n#### 2️⃣ **OVER子句** - 定义窗口\n- 核心关键字，指定函数执行的窗口范围\n\n#### 3️⃣ **三大分析子句**\n- `PARTITION BY` - 🔄 分组子句\n- `ORDER BY` - 📊 排序子句  \n- `ROWS BETWEEN` - 📏 窗口子句\n\n> **通俗理解**：就像做菜的配方，函数是主料，OVER是锅子，三个子句是调料"
    },
    {
      "id": "partition_by_detail",
      "type": "text",
      "x": 1150,
      "y": 550,
      "width": 400,
      "height": 320,
      "color": "2",
      "text": "## 🔄 PARTITION BY 分组详解\n\n### 与GROUP BY的区别\n\n| 特征 | GROUP BY | PARTITION BY |\n|------|----------|-------------|\n| 返回行数 | 减少（每组1行） | 保持原有行数 |\n| 使用场景 | 普通聚合 | 窗口函数 |\n| 结果特点 | 分组汇总 | 每行都有值 |\n\n### 🎯 实际应用场景\n\n```sql\n-- 多年度数据，按年度分别统计累计销售额\nSELECT \n    month_date,\n    sales_amount,\n    SUM(sales_amount) OVER (\n        PARTITION BY YEAR(month_date)\n        ORDER BY month_date\n    ) AS yearly_cumulative\nFROM sales;\n```\n\n### 📊 数据处理逻辑\n- 2019年数据单独成组，内部累计计算\n- 2020年数据单独成组，内部累计计算  \n- **不会跨年度混合计算**\n\n> **通俗理解**：就像分班考试，每个班级内部排名，不会和其他班比较"
    },
    {
      "id": "order_by_detail",
      "type": "text",
      "x": 100,
      "y": 980,
      "width": 400,
      "height": 280,
      "color": "3",
      "text": "## 📊 ORDER BY 排序详解\n\n### 🎯 核心作用\n- 决定窗口函数的**计算顺序**\n- 影响累计计算的**数据流向**\n\n### 📈 排序对累计结果的影响\n\n```sql\n-- 按日期升序（正常时间顺序）\nORDER BY month_date ASC\n结果：1000 → 3000 → 6000 → 10000\n\n-- 按日期降序（倒序时间）  \nORDER BY month_date DESC\n结果：21000 → 20000 → 17000 → 11000\n```\n\n### ⚠️ 注意事项\n- 累计函数**必须有ORDER BY**\n- 排序字段通常是时间或序号\n- 不同排序产生不同的累计路径\n\n> **通俗理解**：就像搭积木，顺序不同，搭出来的形状就不一样"
    },
    {
      "id": "rows_between_detail",
      "type": "text",
      "x": 550,
      "y": 980,
      "width": 500,
      "height": 400,
      "color": "4",
      "text": "## 📏 ROWS BETWEEN 窗口范围详解\n\n### 🎯 精确控制窗口大小\n\n#### 基本语法模式\n```sql\nROWS BETWEEN 起始位置 AND 结束位置\n```\n\n### 📍 位置关键词\n\n| 关键词 | 含义 | 中文理解 |\n|--------|------|----------|\n| `PRECEDING` | 之前 | 往上找 |\n| `FOLLOWING` | 之后 | 往下找 |\n| `CURRENT ROW` | 当前行 | 就是现在这一行 |\n| `UNBOUNDED` | 无边界 | 不限制 |\n\n### 🔥 常用窗口范围组合\n\n```sql\n-- 1. 当前行和前面2行\nROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n\n-- 2. 当前行和之前所有行（累计）\nROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n\n-- 3. 当前行和后面2行\nROWS BETWEEN CURRENT ROW AND 2 FOLLOWING\n\n-- 4. 前面3行到后面1行（共5行窗口）\nROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING\n\n-- 5. 整个分组的所有行\nROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n```\n\n> **通俗理解**：就像设定监控摄像头的拍摄范围，可以拍前面、后面、还是全景"
    },
    {
      "id": "default_behavior",
      "type": "text",
      "x": 1100,
      "y": 980,
      "width": 400,
      "height": 300,
      "color": "5",
      "text": "## ⚙️ 窗口函数默认行为\n\n### 🎯 三种省略情况\n\n#### 1️⃣ 只有ORDER BY，省略ROWS\n```sql\nOVER (ORDER BY date)\n-- 默认等同于：\nOVER (ORDER BY date \n      ROWS BETWEEN UNBOUNDED PRECEDING \n      AND CURRENT ROW)\n```\n**效果**：累计计算（最常用）\n\n#### 2️⃣ 只有PARTITION BY，省略ORDER BY和ROWS\n```sql\nOVER (PARTITION BY year)\n-- 默认等同于：\nOVER (PARTITION BY year\n      ROWS BETWEEN UNBOUNDED PRECEDING \n      AND UNBOUNDED FOLLOWING)\n```\n**效果**：分组内全部数据计算\n\n#### 3️⃣ 空的OVER子句\n```sql\nOVER ()\n```\n**效果**：整表数据计算\n\n> **通俗理解**：就像手机的自动设置，不设置就用最合理的默认值"
    },
    {
      "id": "complete_example",
      "type": "text",
      "x": 200,
      "y": 1430,
      "width": 600,
      "height": 450,
      "color": "1",
      "text": "## 🎯 完整实战示例\n\n### 💰 销售数据累计分析\n\n```sql\n-- 创建测试数据\nCREATE TABLE monthly_sales (\n    sale_date DATE,\n    amount DECIMAL(10,2)\n);\n\nINSERT INTO monthly_sales VALUES\n('2019-01-01', 1000.00),\n('2019-02-01', 2000.00),\n('2019-03-01', 3000.00),\n('2019-04-01', 4000.00),\n('2019-05-01', 5000.00),\n('2019-06-01', 6000.00);\n\n-- 窗口函数查询：累计销售额\nSELECT \n    sale_date,\n    amount AS monthly_amount,\n    SUM(amount) OVER (\n        ORDER BY sale_date\n        ROWS BETWEEN UNBOUNDED PRECEDING \n        AND CURRENT ROW\n    ) AS cumulative_amount,\n    -- 计算增长率\n    ROUND(\n        (amount * 100.0 / \n         LAG(amount) OVER (ORDER BY sale_date) - 100), 2\n    ) AS growth_rate_percent\nFROM monthly_sales\nORDER BY sale_date;\n```\n\n### 📊 查询结果\n| 日期 | 当月销售额 | 累计销售额 | 增长率% |\n|------|------------|------------|----------|\n| 2019-01 | ¥1,000 | ¥1,000 | NULL |\n| 2019-02 | ¥2,000 | ¥3,000 | 100.00% |\n| 2019-03 | ¥3,000 | ¥6,000 | 50.00% |\n| 2019-04 | ¥4,000 | ¥10,000 | 33.33% |\n| 2019-05 | ¥5,000 | ¥15,000 | 25.00% |\n| 2019-06 | ¥6,000 | ¥21,000 | 20.00% |\n\n> **通俗理解**：这就像银行账户的流水记录，既能看到每笔交易，又能看到账户余额变化"
    },
    {
      "id": "advanced_functions",
      "type": "text",
      "x": 850,
      "y": 1430,
      "width": 450,
      "height": 400,
      "color": "6",
      "text": "## 🚀 高级窗口函数类型\n\n### 1️⃣ **聚合函数类**\n- `SUM()` - 求和\n- `COUNT()` - 计数\n- `AVG()` - 平均值\n- `MAX()`, `MIN()` - 最值\n\n### 2️⃣ **排名函数类**\n```sql\n-- 排名相关\nROW_NUMBER() OVER (ORDER BY score DESC)  -- 连续排名\nRANK() OVER (ORDER BY score DESC)        -- 跳跃排名  \nDENSE_RANK() OVER (ORDER BY score DESC)  -- 密集排名\n```\n\n### 3️⃣ **偏移函数类**\n```sql\n-- 取前后行数据\nLAG(amount, 1) OVER (ORDER BY date)      -- 上一行\nLEAD(amount, 1) OVER (ORDER BY date)     -- 下一行\nFIRST_VALUE(amount) OVER (...)           -- 窗口第一个值\nLAST_VALUE(amount) OVER (...)            -- 窗口最后一个值\n```\n\n### 4️⃣ **分布函数类**\n```sql\nPERCENT_RANK() OVER (...)                -- 百分比排名\nCUME_DIST() OVER (...)                   -- 累积分布\nNTILE(4) OVER (ORDER BY score)          -- 四分位数\n```\n\n### 🎯 实际应用场景\n- **销售排名分析**：哪个销售员业绩最好？\n- **同比环比分析**：这个月比上个月增长多少？\n- **分组统计**：按地区、按产品线分别统计\n- **异常检测**：哪些数据偏离正常范围？\n\n> **通俗理解**：就像瑞士军刀，一个工具包含多种功能，适用不同场景"
    },
    {
      "id": "performance_tips",
      "type": "text",
      "x": 200,
      "y": 1930,
      "width": 400,
      "height": 300,
      "color": "2",
      "text": "## ⚡ 性能优化技巧\n\n### 🎯 提升窗口函数性能\n\n#### 1️⃣ **索引优化**\n```sql\n-- 为ORDER BY字段创建索引\nCREATE INDEX idx_sales_date \nON monthly_sales(sale_date);\n\n-- 为PARTITION BY字段创建索引\nCREATE INDEX idx_sales_year_date \nON monthly_sales(year, sale_date);\n```\n\n#### 2️⃣ **合理设置窗口大小**\n- 避免使用`UNBOUNDED`（除非必要）\n- 限制窗口行数范围\n- 使用具体的行数范围\n\n#### 3️⃣ **分区策略**\n- 合理使用`PARTITION BY`减少计算范围\n- 避免过大的分区\n\n#### 4️⃣ **查询优化**\n```sql\n-- 好的做法：限制数据范围\nSELECT ... FROM sales \nWHERE sale_date >= '2019-01-01'\nWINDOW w AS (ORDER BY sale_date);\n```\n\n> **通俗理解**：就像开车要选最优路线，数据库查询也要找最快路径"
    },
    {
      "id": "common_mistakes",
      "type": "text",
      "x": 650,
      "y": 1930,
      "width": 400,
      "height": 320,
      "color": "3",
      "text": "## ⚠️ 常见错误与避坑指南\n\n### 🚫 典型错误案例\n\n#### 1️⃣ **忘记ORDER BY**\n```sql\n-- ❌ 错误：累计函数没有排序\nSUM(amount) OVER ()\n\n-- ✅ 正确：指定排序\nSUM(amount) OVER (ORDER BY date)\n```\n\n#### 2️⃣ **窗口范围理解错误**\n```sql\n-- ❌ 混淆：以为是取3行数据\nROWS BETWEEN 3 PRECEDING AND CURRENT ROW\n-- 实际：当前行+前面3行 = 共4行\n\n-- ✅ 正确理解：明确行数\nROWS BETWEEN 2 PRECEDING AND CURRENT ROW -- 共3行\n```\n\n#### 3️⃣ **NULL值处理不当**\n```sql\n-- ❌ 没考虑NULL值影响\nLAG(amount) OVER (ORDER BY date)\n\n-- ✅ 处理NULL值\nCOALESCE(LAG(amount) OVER (ORDER BY date), 0)\n```\n\n#### 4️⃣ **版本兼容性问题**\n- MySQL 8.0以下版本不支持\n- 生产环境需确认版本\n\n> **通俗理解**：学会了语法，还要知道常见的陷阱在哪里"
    },
    {
      "id": "practical_exercises",
      "type": "text",
      "x": 1100,
      "y": 1930,
      "width": 400,
      "height": 350,
      "color": "4",
      "text": "## 🎓 实战练习题\n\n### 📊 练习数据准备\n```sql\nCREATE TABLE student_scores (\n    student_id INT,\n    subject VARCHAR(50),\n    score INT,\n    exam_date DATE\n);\n```\n\n### 🎯 练习题目\n\n#### 题目1：成绩排名\n**需求**：计算每个学科的成绩排名\n```sql\n-- 你的答案：\nSELECT student_id, subject, score,\n       RANK() OVER (PARTITION BY subject \n                    ORDER BY score DESC) as rank_in_subject\nFROM student_scores;\n```\n\n#### 题目2：成绩趋势分析\n**需求**：计算每个学生的成绩变化（与上次考试对比）\n\n#### 题目3：移动平均分\n**需求**：计算最近3次考试的平均分\n\n#### 题目4：累计通过率\n**需求**：计算截止到每次考试的累计通过率（≥60分）\n\n### 💡 练习提示\n- 先理解需求，再选择合适的窗口函数\n- 注意分组和排序的逻辑\n- 测试边界情况（如第一次考试）\n\n> **通俗理解**：纸上得来终觉浅，绝知此事要躬行"
    },
    {
      "id": "summary_key_points",
      "type": "text",
      "x": 300,
      "y": 2330,
      "width": 500,
      "height": 320,
      "color": "5",
      "text": "## 📚 核心知识点总结\n\n### 🎯 窗口函数五大要点\n\n1️⃣ **概念理解**\n- 窗口 = 动态的数据观察范围\n- 每行都有结果（区别于GROUP BY）\n\n2️⃣ **语法结构**\n```sql\n函数名() OVER (\n    PARTITION BY -- 分组\n    ORDER BY     -- 排序  \n    ROWS BETWEEN -- 窗口范围\n)\n```\n\n3️⃣ **三大子句作用**\n- `PARTITION BY`：数据分组（可选）\n- `ORDER BY`：计算顺序（累计必须）\n- `ROWS BETWEEN`：精确控制窗口大小\n\n4️⃣ **常用函数类型**\n- 聚合类：SUM、COUNT、AVG\n- 排名类：RANK、ROW_NUMBER\n- 偏移类：LAG、LEAD\n\n5️⃣ **实际应用**\n- 累计统计、排名分析、同比环比\n- 移动平均、趋势分析\n\n> **记忆口诀**：窗口函数像放大镜，圈定范围做统计，每行都有一结果，分析报表特别棒！"
    },
    {
      "id": "next_steps",
      "type": "text",
      "x": 850,
      "y": 2330,
      "width": 400,
      "height": 280,
      "color": "6",
      "text": "## 🚀 下一步学习规划\n\n### 📈 进阶学习路径\n\n#### 1️⃣ **深入窗口函数**\n- 更多高级函数（PERCENTILE、NTILE）\n- 复杂业务场景应用\n- 性能调优实战\n\n#### 2️⃣ **MySQL索引技术**\n- 索引原理与类型\n- 查询优化策略\n- 执行计划分析\n\n#### 3️⃣ **MySQL视图应用**\n- 视图创建与管理\n- 复杂查询简化\n- 数据安全控制\n\n#### 4️⃣ **综合项目实战**\n- 电商数据分析系统\n- 用户行为分析平台\n- 财务报表自动化\n\n### 🎯 学习建议\n- **多练习**：理论+实战相结合\n- **多思考**：为什么这样设计？\n- **多总结**：建立自己的知识体系\n\n> **通俗理解**：学会了窗口函数，就像掌握了数据分析的\"显微镜\"，能看到更细节的数据规律"
    }
  ],
  "edges": []
} 