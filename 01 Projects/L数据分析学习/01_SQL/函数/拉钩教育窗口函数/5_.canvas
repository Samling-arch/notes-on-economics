{
	"nodes":[
		{"id":"title_node","type":"text","text":"# 拉钩教育数据分析训练营：窗口函数进阶应用\n\n**需求2：多年度累计统计** | 经典老师 | 2021-05-18\n\n> 这节课我们学习如何使用PARTITION BY实现跨年度的累计统计分析","x":400,"y":-100,"width":700,"height":140,"color":"4"},
		{"id":"requirement_comparison","type":"text","text":"# 需求对比分析\n\n## 需求1 vs 需求2\n\n### 需求1（已完成）\n- **时间范围**: 仅2019年\n- **累计方式**: 全年累计\n- **分区情况**: 无需分区\n\n### 需求2（当前）\n- **时间范围**: 2018年 + 2019年\n- **累计方式**: 各年度内累计\n- **分区情况**: 按年度分区\n\n## 核心差异\n- **数据范围扩大**: 从1年扩展到2年\n- **分区概念引入**: 需要PARTITION BY\n- **累计逻辑**: 年度内累计，不跨年\n\n> **通俗理解**：就像分别统计2018年和2019年的月度累计，两年的数据不能混在一起算","x":50,"y":100,"width":350,"height":300,"color":"1"},
		{"id":"new_requirement","type":"text","text":"# 新需求详细描述\n\n## 具体要求\n**查询出2018年到2019年每月的支付总额和当年累计支付总额**\n\n## 期望结果格式\n| 年份 | 月份 | 当月支付总额 | 年度累计支付总额 |\n|------|------|-------------|----------------|\n| 2018 | 1 | $A_{18,1}$ | $A_{18,1}$ |\n| 2018 | 2 | $A_{18,2}$ | $A_{18,1} + A_{18,2}$ |\n| ... | ... | ... | ... |\n| 2018 | 12 | $A_{18,12}$ | $\\sum_{i=1}^{12} A_{18,i}$ |\n| 2019 | 1 | $A_{19,1}$ | $A_{19,1}$ |\n| 2019 | 2 | $A_{19,2}$ | $A_{19,1} + A_{19,2}$ |\n| ... | ... | ... | ... |\n\n## 关键要求\n- **不跨年累计**: 2019年1月不包含2018年数据\n- **年度内累计**: 每年内部按月累计\n- **多年显示**: 同时显示两年数据\n\n> **通俗理解**：就像分别计算两个人的月度储蓄累计，各算各的账","x":450,"y":100,"width":400,"height":300,"color":"2"},
		{"id":"partition_concept","type":"text","text":"# PARTITION BY 核心概念\n\n## 分区机制原理\n```sql\nSUM(column) OVER (\n    PARTITION BY partition_column\n    ORDER BY order_column\n)\n```\n\n## 分区作用机制\n1. **数据分组**: 将数据按分区列分成若干组\n2. **独立计算**: 每个分区内独立进行窗口计算\n3. **隔离性**: 分区之间互不影响\n\n## 本例中的分区\n- **分区列**: YEAR(pay_time)\n- **分区效果**: 2018年一组，2019年一组\n- **计算隔离**: 2018年累计不包含2019年数据\n\n## 数学表达式\n$$\\text{分区}_i \\text{累计值}_j = \\sum_{k=1}^{j} \\text{分区}_i \\text{当期值}_k$$\n\n其中：$i$ 表示分区编号，$j$ 表示分区内序号\n\n> **通俗理解**：就像把数据分成几个独立的小组，每个小组内部单独计算，小组之间不互相影响","x":900,"y":100,"width":450,"height":320,"color":"3"},
		{"id":"step1_data_filter","type":"text","text":"# Step 1: 扩展数据过滤\n\n## 多年数据过滤\n```sql\nSELECT * \nFROM user_trade \nWHERE YEAR(pay_time) = 2018 \n   OR YEAR(pay_time) = 2019;\n```\n\n## 更简洁的写法\n```sql\nSELECT * \nFROM user_trade \nWHERE YEAR(pay_time) IN (2018, 2019);\n```\n\n## 关键变化\n- **条件扩展**: 从单年扩展到多年\n- **逻辑运算**: 使用OR或IN操作符\n- **数据范围**: 包含两年完整数据\n\n## 执行结果\n- 包含2018年所有订单记录\n- 包含2019年所有订单记录\n- 为后续按年月分组做准备\n\n> **通俗理解**：从只看2019年的账单，扩展到看2018和2019两年的账单","x":50,"y":500,"width":350,"height":280,"color":"5"},
		{"id":"advanced_applications","type":"text","text":"# 进阶应用扩展\n\n## 多维分区应用\n```sql\n-- 按年度和商品类别分区\nSUM(payment) OVER (\n    PARTITION BY YEAR(pay_time), goods_category\n    ORDER BY MONTH(pay_time)\n)\n```\n\n## 分区内多种统计\n```sql\nSELECT \n    year, month, payment,\n    SUM(payment) OVER w as 累计,\n    AVG(payment) OVER w as 平均,\n    COUNT(*) OVER w as 累计月数\nWINDOW w AS (\n    PARTITION BY year \n    ORDER BY month\n)\n```\n\n## 复杂分区场景\n- **按季度分区**: 实现季度内累计\n- **按用户分区**: 实现用户维度累计\n- **按地区分区**: 实现地区维度累计\n\n## 性能优化\n- **索引策略**: 分区列和排序列建立复合索引\n- **数据倾斜**: 注意分区数据分布均匀性\n- **内存使用**: 大分区可能消耗更多内存\n\n> **拓展思维**：分区是窗口函数的核心特性，掌握它可以解决复杂的多维度统计问题","x":900,"y":950,"width":450,"height":320,"color":"5"},
		{"id":"syntax_comparison","type":"text","text":"# 语法对比总结\n\n## 需求1语法（无分区）\n```sql\nSUM(payment) OVER (\n    ORDER BY month\n)\n```\n- **窗口范围**: 全部数据\n- **累计方式**: 从第一行到当前行\n- **适用场景**: 单一维度累计\n\n## 需求2语法（有分区）\n```sql\nSUM(payment) OVER (\n    PARTITION BY year\n    ORDER BY month\n)\n```\n- **窗口范围**: 分区内数据\n- **累计方式**: 分区内从第一行到当前行\n- **适用场景**: 多维度独立累计\n\n## 语法要素对比\n| 要素 | 需求1 | 需求2 |\n|------|-------|-------|\n| PARTITION BY | ❌ | ✅ |\n| ORDER BY | ✅ | ✅ |\n| 分区数量 | 1 | 2+ |\n| 累计重置 | ❌ | ✅ |\n\n> **语法精髓**：PARTITION BY是实现分组独立计算的关键","x":1400,"y":100,"width":300,"height":400,"color":"1"},
		{"id":"common_mistakes","type":"text","text":"# 常见错误与避免\n\n## 错误1：忘记分区\n```sql\n-- 错误：没有分区，会跨年累计\nSUM(payment) OVER (ORDER BY year, month)\n\n-- 正确：按年分区\nSUM(payment) OVER (\n    PARTITION BY year \n    ORDER BY month\n)\n```\n\n## 错误2：分区列错误\n```sql\n-- 错误：按月分区（过度分区）\nPARTITION BY month\n\n-- 正确：按年分区\nPARTITION BY year\n```\n\n## 错误3：排序列错误\n```sql\n-- 错误：按年排序（分区内无意义）\nORDER BY year\n\n-- 正确：按月排序\nORDER BY month\n```\n\n## 调试技巧\n1. **逐步构建**: 先无分区，再加分区\n2. **数据检查**: 验证分区边界\n3. **结果对比**: 手工计算验证\n\n> **避坑指南**：理解分区和排序的作用域是关键","x":1400,"y":550,"width":300,"height":350,"color":"6"},
		{"id":"next_lesson_preview","type":"text","text":"# 下节课预告\n\n## 排序函数详解\n- **ROW_NUMBER()**: 行号生成\n- **RANK()**: 并列排名（跳跃）\n- **DENSE_RANK()**: 密集排名\n\n## 实战案例\n- 销售业绩排行榜\n- 商品销量Top N\n- 用户积分排名\n\n## 迁移分析函数\n- **LAG/LEAD**: 前后值对比\n- **同比环比**: 数据趋势分析\n\n## 学习重点\n1. 排序函数的区别\n2. 排名逻辑的理解\n3. 业务场景的应用\n4. 性能优化技巧\n\n> **学习建议**：累计统计掌握后，排序分析是下一个重要技能点","x":1400,"y":950,"width":300,"height":280,"color":"4"},
		{"id":"step2_group_by_year_month","type":"text","text":"# Step 2: 按年月分组统计\n\n## 双维度分组\n```sql\nSELECT \n    YEAR(pay_time) as year,\n    MONTH(pay_time) as month,\n    SUM(payment) as payment\nFROM user_trade \nWHERE YEAR(pay_time) IN (2018, 2019)\nGROUP BY YEAR(pay_time), MONTH(pay_time);\n```\n\n## 分组维度分析\n- **第一维度**: YEAR(pay_time) - 按年分组\n- **第二维度**: MONTH(pay_time) - 按月分组\n- **组合效果**: 形成\"年-月\"的组合分组\n\n## 执行结果示例\n```\nyear | month | payment\n2018 | 1     | 55623.45\n2018 | 2     | 82471.90\n...\n2019 | 1     | 97199.99\n2019 | 2     | 221453.7\n...\n```\n\n> **通俗理解**：把账单先按年份分类，再在每年内按月份分类，形成年月组合的统计","x":450,"y":480,"width":400,"height":320,"color":"6"},
		{"id":"step3_partition_window","type":"text","text":"# Step 3: 分区窗口函数应用\n\n## 完整SQL语句\n```sql\nSELECT \n    a.year,\n    a.month,\n    a.payment as 当月支付金额,\n    SUM(a.payment) OVER (\n        PARTITION BY a.year\n        ORDER BY a.month\n    ) as 年度累计支付金额\nFROM (\n    SELECT \n        YEAR(pay_time) as year,\n        MONTH(pay_time) as month,\n        SUM(payment) as payment\n    FROM user_trade \n    WHERE YEAR(pay_time) IN (2018, 2019)\n    GROUP BY YEAR(pay_time), MONTH(pay_time)\n) a;\n```\n\n## 关键语法解析\n- **PARTITION BY a.year**: 按年份分区\n- **ORDER BY a.month**: 分区内按月份排序\n- **SUM() OVER()**: 分区内累计求和\n\n## 分区工作机制\n1. **2018年分区**: 独立计算2018年月度累计\n2. **2019年分区**: 独立计算2019年月度累计\n3. **隔离计算**: 两个分区互不干扰\n\n> **通俗理解**：就像两个独立的存钱罐，每个存钱罐内部计算累计金额，两个存钱罐之间不相互影响","x":900,"y":450,"width":450,"height":380,"color":"4"},
		{"id":"partition_mechanism","type":"text","text":"# 分区机制深度解析\n\n## 分区边界定义\n- **分区1**: YEAR = 2018 的所有行\n- **分区2**: YEAR = 2019 的所有行\n- **边界清晰**: 不存在跨分区的窗口\n\n## 窗口范围\n在每个分区内：\n- **起始**: 分区第一行\n- **结束**: 当前行\n- **累计**: 分区内从第一行到当前行\n\n## 数学模型\n```\n2018年分区:\n  1月: SUM(2018年1月)\n  2月: SUM(2018年1月 + 2018年2月)\n  ...\n  \n2019年分区:\n  1月: SUM(2019年1月)  # 重新开始\n  2月: SUM(2019年1月 + 2019年2月)\n  ...\n```\n\n## 重置机制\n每个新分区都会重置累计计算的起点\n\n> **通俗理解**：就像每年重新开始记账，新年第一个月的累计金额就是当月金额","x":50,"y":970,"width":350,"height":300,"color":"2"},
		{"id":"result_analysis","type":"text","text":"# 执行结果分析\n\n## 实际输出示例\n\nyear | month | 当月支付金额 | 年度累计支付金额\n2018 | 1     | 55623.45    | 55623.45\n2018 | 2     | 82471.90    | 138095.35\n2018 | 3     | 76234.12    | 214329.47\n...\n2019 | 1     | 97199.99    | 97199.99     # 重新开始\n2019 | 2     | 221453.7    | 318653.69\n2019 | 3     | 189076.5    | 507730.19\n\n\n```\n\n## 数据验证\n- **2018年累计**: 逐月递增，年底达到最大值\n- **2019年重置**: 从2019年1月重新开始累计\n- **分区隔离**: 2019年1月累计不包含2018年数据\n\n## 业务价值\n- **年度对比**: 可以对比不同年度的同期累计\n- **趋势分析**: 观察各年度内的增长趋势\n- **预测模型**: 基于历史累计数据进行预测\n\n> **通俗理解**：就像分别看2018年和2019年的存款增长曲线，每年都有独立的增长轨迹","x":450,"y":960,"width":400,"height":320,"color":"3"}
	],
	"edges":[
		{"id":"edge1","fromNode":"title_node","fromSide":"bottom","toNode":"requirement_comparison","toSide":"right","color":"4"},
		{"id":"edge2","fromNode":"requirement_comparison","fromSide":"right","toNode":"new_requirement","toSide":"left","color":"1"},
		{"id":"edge3","fromNode":"new_requirement","fromSide":"right","toNode":"partition_concept","toSide":"left","color":"2"},
		{"id":"edge4","fromNode":"requirement_comparison","fromSide":"bottom","toNode":"step1_data_filter","toSide":"top","color":"5"},
		{"id":"edge5","fromNode":"step1_data_filter","fromSide":"right","toNode":"step2_group_by_year_month","toSide":"left","color":"6"},
		{"id":"edge6","fromNode":"step2_group_by_year_month","fromSide":"right","toNode":"step3_partition_window","toSide":"left","color":"4"},
		{"id":"edge7","fromNode":"step3_partition_window","fromSide":"left","toNode":"partition_mechanism","toSide":"right","color":"2"},
		{"id":"edge8","fromNode":"partition_mechanism","fromSide":"right","toNode":"result_analysis","toSide":"left","color":"3"},
		{"id":"edge9","fromNode":"result_analysis","fromSide":"right","toNode":"advanced_applications","toSide":"left","color":"5"},
		{"id":"edge10","fromNode":"partition_concept","fromSide":"right","toNode":"syntax_comparison","toSide":"left","color":"1"},
		{"id":"edge11","fromNode":"step3_partition_window","fromSide":"right","toNode":"common_mistakes","toSide":"left","color":"6"},
		{"id":"edge12","fromNode":"advanced_applications","fromSide":"right","toNode":"next_lesson_preview","toSide":"left","color":"4"},
		{"id":"edge13","fromNode":"syntax_comparison","fromSide":"bottom","toNode":"common_mistakes","toSide":"top","color":"1"},
		{"id":"edge14","fromNode":"common_mistakes","fromSide":"bottom","toNode":"next_lesson_preview","toSide":"top","color":"6"}
	]
}