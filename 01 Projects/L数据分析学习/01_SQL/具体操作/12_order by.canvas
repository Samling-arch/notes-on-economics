{
	"nodes":[
		{"id":"execution_order","type":"text","text":"# SQL执行顺序深入理解\n\n## 💡 核心概念\n**通俗解释：SQL不是从左到右执行的，而是有自己的执行顺序，就像做菜有固定步骤**\n\n## 🔄 完整执行顺序\n```\n1. FROM    ← 先找到表（找食材）\n2. WHERE   ← 筛选记录（挑选食材）\n3. SELECT  ← 选择字段（决定做什么菜）\n4. ORDER BY← 排序结果（摆盘装饰）\n```\n\n### 📚 详细执行流程\n```sql\nSELECT name, salary     -- ③ 第三步：选择显示字段\nFROM EMP               -- ① 第一步：找到EMP表\nWHERE salary > 8000    -- ② 第二步：筛选高薪员工\nORDER BY salary DESC;  -- ④ 第四步：按工资排序\n```\n\n### ⚠️ 重要提醒\n- **别名问题：** 为什么有些地方不能用别名？\n- **语法错误：** 因为执行顺序导致的\n- **理解关键：** 掌握执行顺序避免语法错误\n\n### 🎯 实际意义\n理解执行顺序帮助：\n1. 写出正确的SQL语句\n2. 理解语法报错原因\n3. 优化查询性能","x":1960,"y":470,"width":450,"height":380,"color":"1"},
		{"id":"multi_field_sort","type":"text","text":"# 多字段排序策略\n\n## 💡 核心概念\n**通俗解释：多字段排序就像体育比赛，先比第一项，相同的再比第二项**\n\n## 🎯 问题场景\n当某个字段值相同时怎么办？\n- 4个员工工资都是 $6000\n- 谁应该排在前面？\n\n## 📊 解决方案：多字段排序\n```sql\n-- 先按工资排序，工资相同再按年龄排序\nSELECT * FROM EMP \nORDER BY salary, age;\n```\n\n### 🔄 排序优先级\n1. **主排序：** `salary`（薪资优先）\n2. **次排序：** `age`（年龄次要）\n3. **第三排序：** `id`（最终保底）\n\n```sql\n-- 三个字段完整排序\nSELECT * FROM EMP \nORDER BY salary, age, id;\n```\n\n### 📈 执行结果逻辑\n- 薪资6000: 24岁→28岁→32岁\n- 薪资相同时按年龄从小到大\n- 年龄也相同时按ID排序","x":-880,"y":450,"width":400,"height":350,"color":"6"},
		{"id":"where_orderby","type":"text","text":"# WHERE + ORDER BY 组合使用\n\n## 💡 核心概念\n**通俗解释：先用WHERE筛选出符合条件的人，再对这些人进行排序**\n\n## 🎯 实际应用场景\n```sql\n-- 工资大于8000的员工，按工资降序排列\nSELECT * FROM EMP \nWHERE salary > 8000 \nORDER BY salary DESC;\n```\n\n### 📊 执行过程分析\n1. **筛选阶段：** `WHERE salary > 8000`\n   - 原32条记录→筛选后17条记录\n2. **排序阶段：** `ORDER BY salary DESC`\n   - 对17条记录按工资从高到低排序\n3. **最终结果：** 高薪员工从12000到9000排列\n\n### ⚡ 性能优势\n- 先筛选减少数据量\n- 再排序提高效率\n- 避免对全表进行不必要的排序","x":300,"y":470,"width":400,"height":300,"color":"2"},
		{"id":"storage_principle","type":"text","text":"# MySQL存储原理简介\n\n## 💡 核心概念\n**通俗解释：MySQL存储数据不像我们想象的按顺序排列，而是用树形结构**\n\n## 🌳 存储结构特点\n- **数据结构：** 树形结构存储\n- **不是顺序：** 不按1,2,3,4顺序存储\n- **默认顺序：** 按存储位置的物理顺序\n\n### 🔍 为什么相同值的排序看起来无序？\n```sql\n-- 相同工资的员工ID顺序\nSELECT * FROM EMP ORDER BY salary;\n```\n\n**现象：** 工资相同的员工ID不是连续的\n**原因：** 按照树形存储的物理位置排序\n\n### 📊 解决方案\n明确指定第二排序字段，不依赖默认排序","x":-100,"y":990,"width":400,"height":280,"color":"3"},
		{"id":"practical_examples","type":"text","text":"# 实际应用案例集合\n\n## 💡 核心概念\n**通俗解释：把ORDER BY应用到实际工作场景中**\n\n## 📊 常见业务场景\n\n### 🏆 排行榜查询\n```sql\n-- 销售业绩前10名\nSELECT * FROM sales \nORDER BY amount DESC \nLIMIT 10;\n```\n\n### 📅 时间排序\n```sql\n-- 最新注册用户\nSELECT * FROM users \nORDER BY create_time DESC;\n```\n\n### 💰 价格排序\n```sql\n-- 商品价格从低到高\nSELECT * FROM products \nWHERE category = '手机' \nORDER BY price ASC;\n```\n\n### 📈 复合排序\n```sql\n-- 先按部门，再按工资排序\nSELECT * FROM employees \nORDER BY department, salary DESC;\n```","x":400,"y":1120,"width":400,"height":300,"color":"4"},
		{"id":"common_mistakes","type":"text","text":"# 常见错误与避免方法\n\n## 💡 核心概念\n**通俗解释：学会识别和避免ORDER BY使用中的常见陷阱**\n\n## ❌ 常见错误类型\n\n### 1️⃣ 语法位置错误\n```sql\n-- ❌ 错误：ORDER BY位置不对\nSELECT * ORDER BY age FROM EMP;\n\n-- ✅ 正确：ORDER BY在最后\nSELECT * FROM EMP ORDER BY age;\n```\n\n### 2️⃣ 字段名错误\n```sql\n-- ❌ 错误：字段名不存在\nORDER BY ages;  -- 应该是age\n\n-- ✅ 正确：使用正确字段名\nORDER BY age;\n```\n\n### 3️⃣ 多字段排序混淆\n```sql\n-- 理解：每个字段可以独立指定ASC/DESC\nORDER BY salary DESC, age ASC;\n```\n\n### 🎯 最佳实践\n- 检查字段名拼写\n- 确认ORDER BY位置\n- 明确指定ASC/DESC","x":1075,"y":1360,"width":400,"height":320,"color":"5"},
		{"id":"performance_tips","type":"text","text":"# 性能优化建议\n\n## 💡 核心概念\n**通俗解释：让ORDER BY跑得更快的小技巧**\n\n## ⚡ 优化策略\n\n### 🎯 索引优化\n- 对经常排序的字段建立索引\n- 复合索引覆盖多字段排序\n\n### 📊 数据量控制\n```sql\n-- 先筛选再排序（推荐）\nWHERE conditions ORDER BY field;\n-- 而不是先排序再筛选\n```\n\n### 🔄 LIMIT配合使用\n```sql\n-- 只取需要的记录数\nORDER BY field LIMIT 10;\n```\n\n### 💾 避免复杂排序\n- 避免过多字段同时排序\n- 考虑业务是否真的需要精确排序\n\n## 📈 监控性能\n使用EXPLAIN查看执行计划","x":1720,"y":1280,"width":350,"height":280,"color":"6"},
		{"id":"default_order","type":"text","text":"# 默认排序规律发现\n\n## 💡 核心概念\n**通俗解释：数据库里的记录其实是有默认顺序的，就像图书馆的书有编号一样**\n\n## 🔍 观察现象\n```sql\nSELECT * FROM EMP;\n```\n\n### 默认排序规则\n- 📊 **按ID从低到高排序**\n- 🎯 每次执行结果位置不变\n- 🔢 即使不声明ID，系统也会分配一个\n- 📚 ID是表中唯一不变的标识符\n\n### 💭 为什么需要ID排序？\n- 其他字段可能完全不同\n- ID保证了记录的唯一性和顺序性","x":-560,"y":100,"width":350,"height":280,"color":"2"},
		{"id":"basic_orderby","type":"text","text":"# ORDER BY 基础语法\n\n## 💡 核心概念\n**通俗解释：ORDER BY就像给学生按成绩排队，想按什么标准排就按什么标准**\n\n## 📝 基本语法结构\n```sql\nSELECT * FROM 表名 ORDER BY 字段名;\n```\n\n### 🎯 语法位置规则\n- ✅ 放在 `SELECT FROM` 后面\n- ✅ 可以放在 `WHERE` 后面\n- 📍 **位置：** `SELECT ... FROM ... [WHERE ...] ORDER BY ...`\n\n### 📊 实际应用\n```sql\n-- 按年龄排序\nSELECT * FROM EMP ORDER BY age;\n```\n\n**结果：** 年龄从小到大显示（19→22→24...）","x":150,"y":90,"width":350,"height":300,"color":"3"},
		{"id":"limit_usage","type":"text","text":"# LIMIT 限制结果数量\n\n## 💡 核心概念\n**通俗解释：LIMIT就像只看排行榜前几名，不看全部排名**\n\n## 🏆 获取前N名\n```sql\n-- 工资最高的前3名员工\nSELECT * FROM EMP \nORDER BY salary DESC \nLIMIT 3;\n```\n\n### 🎯 使用步骤\n1. **第一步：** 先用 `ORDER BY` 排序\n2. **第二步：** 再用 `LIMIT` 取前几条\n\n### 📊 实际结果\n- 3个员工工资都是 $12000\n- 成功找到公司薪资前三名\n\n### 💼 常见应用场景\n- 前10名销售员\n- 最新5条新闻\n- 评分最高的3个产品","x":1475,"y":100,"width":350,"height":280,"color":"5"},
		{"id":"asc_desc","type":"text","text":"# 升序与降序控制\n\n## 💡 核心概念\n**通俗解释：升序像爬楼梯往上走，降序像坐滑梯往下滑**\n\n## 📈 升序 (ASC)\n```sql\nSELECT * FROM EMP ORDER BY age ASC;\n-- 或者直接省略ASC（默认升序）\nSELECT * FROM EMP ORDER BY age;\n```\n- 🔢 **含义：** 从小到大排列\n- ⚡ **默认行为：** 不写就是升序\n\n## 📉 降序 (DESC)\n```sql\nSELECT * FROM EMP ORDER BY age DESC;\n```\n- 🔢 **含义：** 从大到小排列\n- 🎯 **应用场景：** 找最高工资、最大年龄等\n\n### 💰 薪资排序示例\n```sql\n-- 工资最高的员工\nSELECT * FROM EMP ORDER BY salary DESC;\n```","x":800,"y":90,"width":350,"height":320,"color":"4"},
		{"id":"title","type":"text","text":"# MySQL从基础到进阶：ORDER BY排序操作详解\n\n**第三节课** | 苑昊老师 | 2024-12-18\n\n[视频链接](https://www.bilibili.com/video/BV1mxrfYsEyP/)\n\n> 通俗总结：学会如何让数据库按照我们想要的顺序显示记录","x":300,"y":-320,"width":600,"height":120,"color":"1"},
		{"id":"a339a4e0b87c6dbc","x":-970,"y":-521,"width":760,"height":523,"type":"file","file":"00-Obsidian/附件/Pasted image 20250609111412.png"}
	],
	"edges":[
		{"id":"edge1","fromNode":"title","fromSide":"bottom","toNode":"default_order","toSide":"right","color":"1","label":"发现默认排序"},
		{"id":"edge2","fromNode":"default_order","fromSide":"right","toNode":"basic_orderby","toSide":"left","color":"2","label":"引入ORDER BY"},
		{"id":"edge3","fromNode":"basic_orderby","fromSide":"right","toNode":"asc_desc","toSide":"left","color":"3","label":"控制排序方向"},
		{"id":"edge4","fromNode":"asc_desc","fromSide":"right","toNode":"limit_usage","toSide":"left","color":"4","label":"限制结果数量"},
		{"id":"edge5","fromNode":"basic_orderby","fromSide":"bottom","toNode":"multi_field_sort","toSide":"top","color":"5","label":"解决相同值问题"},
		{"id":"edge6","fromNode":"multi_field_sort","fromSide":"right","toNode":"where_orderby","toSide":"left","color":"6","label":"条件筛选组合"},
		{"id":"edge7","fromNode":"where_orderby","fromSide":"right","toNode":"execution_order","toSide":"left","color":"1","label":"理解执行顺序"},
		{"id":"edge8","fromNode":"multi_field_sort","fromSide":"bottom","toNode":"storage_principle","toSide":"top","color":"2","label":"存储原理解释"},
		{"id":"edge9","fromNode":"execution_order","fromSide":"left","toNode":"practical_examples","toSide":"top","color":"3","label":"实际应用"},
		{"id":"edge10","fromNode":"practical_examples","fromSide":"right","toNode":"common_mistakes","toSide":"left","color":"4","label":"避免错误"},
		{"id":"edge11","fromNode":"common_mistakes","fromSide":"right","toNode":"performance_tips","toSide":"left","color":"5","label":"性能优化"},
		{"id":"edge12","fromNode":"limit_usage","fromSide":"bottom","toNode":"practical_examples","toSide":"top","color":"6","label":"实战应用"},
		{"id":"8f7ba0c15d1b00db","fromNode":"a339a4e0b87c6dbc","fromSide":"right","toNode":"title","toSide":"left"}
	]
}