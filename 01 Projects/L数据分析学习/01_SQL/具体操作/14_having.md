好的，小白同学你好！这节课苑昊老师主要讲了 `HAVING` 子句，它是跟在 `GROUP BY` 分组查询后面的，用来对分组后的结果进行筛选。我们一步步来看，保证你能理解每一个细节！

# 1 MySQL从基础到进阶 - 分组查询进阶 (`HAVING`子句)
B站视频链接: [https://www.bilibili.com/video/BV1mxrfYsEyP/](https://www.bilibili.com/video/BV1mxrfYsEyP/)
主讲老师: 苑昊
视频发布时间: 2024-12-18 15:23:40 (注意：这个日期是视频中老师设定的一个未来日期，实际上视频发布日期会早于此)

## 1.1 ## 引言：巩固`GROUP BY`与学习`HAVING`
*   **通俗概括:** 这节课我们要在上节课分组的基础上，学习如何在分组 *之后* 进行筛选，并巩固练习。
*   **细节:** 上节课学习了 `GROUP BY`，它可以把数据按照某一列或几列的相同值分成不同的小组。这节课我们要学习一个新的关键字 `HAVING`，它是 `GROUP BY` 的好搭档，专门用来对这些分好的小组进行过滤。

## 1.2 ## 完整的`SELECT`查询语句结构
*   **通俗概括:** 一个完整的查询语句就像搭积木，有很多可选的模块，`HAVING` 是专门跟在 `GROUP BY` 后面，对分组结果进行筛选的模块。
*   **细节:**
    老师提到了一个比较完整的 `SELECT` 语句包含的关键字和它们大致的执行顺序（虽然内部机制更复杂，但这个顺序有助于理解）：
    1.  `SELECT` (选择要显示的列)
    2.  `FROM` (从哪张表里查数据)
    3.  `WHERE` (在分组前，对原始数据行进行筛选)
    4.  `GROUP BY` (对符合 `WHERE` 条件的数据进行分组)
    5.  `HAVING` (对 `GROUP BY` 分组后的结果进行筛选)
    6.  `ORDER BY` (对最终结果进行排序)
    7.  `LIMIT` (限制最终结果显示的条数)
    *   **强调:** `HAVING` 和 `GROUP BY` 是一对，通常一起使用。`HAVING` 是在分组之后对**组**进行筛选。

## 1.3 ## `WHERE` 与 `HAVING` 的核心区别
*   **通俗概括:** `WHERE` 是在分组前就把不符合条件的单条数据过滤掉，而 `HAVING` 是在数据分好组后，再对这些“小组”进行筛选。
*   **细节:**
    *   **`WHERE` 子句 (分组前筛选):**
        *   作用对象：表中的每一条原始记录（行）。
        *   执行时机：在 `GROUP BY` 分组之前。你可以把它想象成是第一道安检，不符合条件的记录直接不让进参与后续的分组。
        *   不能使用的东西：`WHERE` 子句中不能使用聚合函数（比如 `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()`），因为聚合函数是针对组来计算的，而 `WHERE` 执行时，组还没形成呢！
    *   **`HAVING` 子句 (分组后筛选):**
        *   作用对象：`GROUP BY` 之后形成的分组。
        *   执行时机：在 `GROUP BY` 分组之后。这是第二道安检，针对的是已经分好的小组。
        *   可以使用的东西：`HAVING` 子句中可以使用聚合函数，因为它就是对这些聚合函数的计算结果进行筛选的。也可以使用分组的列。
    *   **一句话区分:** `WHERE` 过滤的是**行**，`HAVING` 过滤的是**组**。

---
现在我们通过案例来具体学习和理解。假设我们有一张员工表 `emp`，包含 `name`(姓名), `gender`(性别), `age`(年龄), `salary`(工资), `dept`(部门), `birthday`(生日) 等字段。

## 1.4 ## 案例学习

### 1.4.1 ### 案例1: 查询男女员工各有多少人
*   **通俗概括:** 我们想知道公司里男员工和女员工分别有多少人，这就需要按性别分组统计。
*   **SQL语句:**
    ```sql
    SELECT gender AS '性别', COUNT(*) AS '人数'
    FROM emp
    GROUP BY gender;
    ```
*   **细节解释:**
    1.  `SELECT gender AS '性别', COUNT(*) AS '人数'`:
        *   `gender`: 我们想看每个组的性别是什么。
        *   `COUNT(*)`: 这是聚合函数，`COUNT` 是计数的意思，`*` 通常代表一行中的所有列，这里 `COUNT(*)` 就是统计每个分组里有多少条记录（即多少员工）。
            *   **来源:** `COUNT()` 是SQL标准定义的聚合函数之一，用于计数。
        *   `AS '性别'`, `AS '人数'`: `AS` 关键字用来给查询结果的列起一个别名，让表头更清晰。这里把 `gender` 列显示为“性别”，把 `COUNT(*)` 的结果列显示为“人数”。
    2.  `FROM emp`: 指定数据来源是 `emp` (员工) 表。
    3.  `GROUP BY gender`: 这是核心！告诉数据库按照 `gender` (性别) 这一列的值来分组。比如，所有 `gender` 是 '男' 的记录会成为一组，所有 `gender` 是 '女' 的记录会成为另一组。
*   **预期结果 (示例):**
    | 性别 | 人数 |
    | :--- | :--- |
    | 男   | $18$  |
    | 女   | $14$  |
    *(这里的数字 $18$ 和 $14$ 是老师视频中的示例数据)*

### 1.4.2 ### 案例1拓展: 查询年龄大于 $25$ 岁的男女员工各有多少人
*   **通俗概括:** 在统计男女员工人数之前，我们先只看那些年龄大于 $25$ 岁的员工。
*   **SQL语句:**
    ```sql
    SELECT gender AS '性别', COUNT(*) AS '人数'
    FROM emp
    WHERE age > 25
    GROUP BY gender;
    ```
*   **细节解释:**
    1.  `WHERE age > 25`: 这就是 `WHERE` 子句的应用！
        *   在进行 `GROUP BY gender` 分组之前，数据库会先检查 `emp` 表中的每一行。
        *   只有 `age` 字段的值大于 $25$ 的那些员工记录，才会被留下来参与后续的 `GROUP BY gender` 分组。
        *   如果一个员工的年龄是 $20$ 岁，那么这条记录在这一步就会被过滤掉，不会参与后面的分组和计数。
    2.  其余部分 `SELECT gender AS '性别', COUNT(*) AS '人数'`, `FROM emp`, `GROUP BY gender` 的逻辑和上一个例子相同，只是它们操作的数据集是经过 `WHERE age > 25` 筛选后剩下的数据。
*   **执行顺序理解:**
    1.  `FROM emp`: 找到 `emp` 表。
    2.  `WHERE age > 25`: 从 `emp` 表中筛选出所有年龄大于 $25$ 岁的员工记录。
    3.  `GROUP BY gender`: 将这些筛选出来的员工，再按照性别进行分组。
    4.  `SELECT gender ..., COUNT(*)...`: 对每个性别分组进行计数，并显示性别和对应的人数。
*   **老师强调:** 加了 `WHERE` 条件后，参与分组的总人数会减少（比如从 $32$ 人变成 $16$ 人），所以最后统计出来的男女各自的人数也会相应变化。这体现了 `WHERE` 是在分组前进行过滤。

### 1.4.3 ### 案例2: 查询教学部的员工的最高工资
*   **通俗概括:** 我们想知道“教学部”这个部门里，员工的最高工资是多少。
    老师这里演示了两种思路，我们分别来看：

    *   **思路一: 先分组，再用 `HAVING` 筛选出“教学部”**
        *   **通俗概括 (思路一):** 先算出每个部门的最高工资，然后从这些结果里挑出“教学部”的。
        *   **SQL语句:**
            ```sql
            SELECT dept AS '部门', MAX(salary) AS '最高工资'
            FROM emp
            GROUP BY dept
            HAVING dept = '教学部';
            ```
        *   **细节解释:**
            1.  `SELECT dept AS '部门', MAX(salary) AS '最高工资'`:
                *   `dept`: 显示部门名称。
                *   `MAX(salary)`: 聚合函数，计算每个部门分组内 `salary` (工资) 字段的最大值。
                    *   **来源:** `MAX()` 是SQL标准定义的聚合函数之一，用于找出一组值中的最大值。
                *   `AS '部门'`, `AS '最高工资'`: 起别名。
            2.  `FROM emp`: 数据来自 `emp` 表。
            3.  `GROUP BY dept`: 按照 `dept` (部门) 进行分组。比如教学部一组，运营部一组，销售部一组。
            4.  `HAVING dept = '教学部'`: 这是 `HAVING` 子句！
                *   它在 `GROUP BY dept` 分组完成，并且每个部门的最高工资 (`MAX(salary)`) 也都计算出来之后执行。
                *   此时，我们可能得到类似这样的中间结果（还没被 `HAVING` 过滤）：
                    | 部门   | 最高工资 |
                    | :----- | :------- |
                    | 教学部 | $12000$  |
                    | 运营部 | $12000$  |
                    | 销售部 | $12000$  |
                *   然后 `HAVING dept = '教学部'` 会对这个中间结果进行筛选，只保留 `dept` 列是 '教学部' 的那一行。
        *   **预期结果 (示例):**
            | 部门   | 最高工资 |
            | :----- | :------- |
            | 教学部 | $12000$  |

    *   **思路二: 先用 `WHERE` 筛选出“教学部”员工，再求最高工资**
        *   **通俗概括 (思路二):** 先把所有“教学部”的员工都找出来，然后直接在这些人里找最高的工资。
        *   **SQL语句:**
            ```sql
            SELECT dept AS '部门', MAX(salary) AS '最高工资'
            FROM emp
            WHERE dept = '教学部';
            ```
            *(老师视频中可能写的是 `SELECT '教学部', MAX(salary) ...`，如果 `dept` 列也想从表中直接取，可以这样写。如果只关心最高工资，并且已经确定是教学部，也可以直接写死部门名。)*
        *   **细节解释:**
            1.  `WHERE dept = '教学部'`: 先从 `emp` 表中筛选出所有部门是 '教学部' 的员工记录。
            2.  `SELECT dept, MAX(salary)`: 对这些筛选出来的教学部员工（现在可以看作一个整体大组了），计算他们的最高工资。
                *   **注意:** 这里没有显式的 `GROUP BY` 子句。当聚合函数 (如 `MAX()`) 与 `WHERE` 子句一起使用但没有 `GROUP BY` 时，聚合函数会作用于所有满足 `WHERE` 条件的记录，将它们视为一个单独的组。
        *   **执行顺序理解 (思路二):**
            1.  `FROM emp`: 找到 `emp` 表。
            2.  `WHERE dept = '教学部'`: 筛选出教学部的所有员工。
            3.  `SELECT dept, MAX(salary)`: 在这些教学部员工中找到最高工资，并显示部门名和最高工资。
        *   **老师的补充 (聚合函数不一定需要 `GROUP BY`):**
            查询公司所有员工的平均工资：
            ```sql
            SELECT AVG(salary) AS '公司平均工资' FROM emp;
            ```
            *   **通俗概括:** 聚合函数（如求平均、求和、计数）不一定非要搭配 `GROUP BY`。如果不用 `GROUP BY`，它们会把整张表（或 `WHERE` 筛选后的结果）当作一个大组来计算。
            *   **细节:** `AVG(salary)` 会计算 `emp` 表中所有员工工资的平均值。这里整张表被视为一个大组。
                *   **来源:** `AVG()` 是SQL标准定义的聚合函数之一，用于计算一组数值的平均值。

### 1.4.4 ### 案例3: 查询平均薪水超过 $8500$ 的部门
*   **通俗概括:** 我们想找出哪些部门的平均工资超过了 $8500$ 元。这必须先算出每个部门的平均工资，然后再比较。
*   **SQL语句:**
    ```sql
    SELECT dept AS '部门', AVG(salary) AS 'avg_salary_alias'
    FROM emp
    GROUP BY dept
    HAVING avg_salary_alias > 8500;
    -- 或者，更标准的写法(不依赖别名在HAVING中生效的特性，虽然MySQL支持):
    -- HAVING AVG(salary) > 8500;
    ```
*   **细节解释:**
    1.  `SELECT dept AS '部门', AVG(salary) AS 'avg_salary_alias'`:
        *   `AVG(salary)`: 聚合函数，计算每个部门分组内 `salary` (工资) 的平均值。
        *   `AS 'avg_salary_alias'`: 给计算出来的平均工资起个别名，比如叫 `avg_salary_alias` (老师视频中用了中文和英文的别名做演示，如“平均薪水”或 `avg_salary`)。
    2.  `FROM emp`: 数据来源。
    3.  `GROUP BY dept`: 按部门分组。
    4.  `HAVING avg_salary_alias > 8500`:
        *   关键点！在每个部门的平均工资 (`AVG(salary)`) 计算出来之后，`HAVING` 子句对这些**计算结果**（即每个组的平均工资）进行筛选。
        *   只有那些平均工资大于 $8500$ 的部门组才会被保留下来。
        *   **为什么用 `HAVING` 而不是 `WHERE`?** 因为 `AVG(salary)` 是一个聚合函数的结果，是对分组后的数据进行计算得到的。`WHERE` 子句在分组前执行，那时还不知道每个组的平均工资是多少，所以 `WHERE AVG(salary) > 8500` 是错误的，会报错。
    *   **老师强调的执行顺序细节:**
        `FROM` -> `GROUP BY` -> (聚合函数计算) -> `SELECT` (此时别名 `avg_salary_alias` 才被定义和赋值) -> `HAVING` (可以使用 `SELECT` 中定义的别名)。
        这意味着，`SELECT` 子句（包括聚合函数的计算和别名的定义）在逻辑上是先于 `HAVING` 子句评估的，所以 `HAVING` 可以使用 `SELECT` 中定义的别名（这在 MySQL 中是支持的，但并非所有数据库都支持，标准 SQL 要求在 `HAVING` 中重复聚合函数表达式）。
*   **预期结果 (示例，假设只有教学部和运营部平均薪资超过 $8500$):**
    | 部门   | avg_salary_alias |
    | :----- | :--------------- |
    | 教学部 | $9000$           |
    | 运营部 | $8700$           |

### 1.4.5 ### 案例3拓展: 查询薪水超过 $8000$ 的所有员工的前提下，再计算这些员工在各自部门的平均薪资
*   **通俗概括:** 我们想计算每个部门的平均工资，但这次只考虑那些本身工资就超过 $8000$ 元的员工，工资不到 $8000$ 的不参与后续的部门平均工资计算。
*   **SQL语句:**
    ```sql
    SELECT dept AS '部门', AVG(salary) AS '部门高薪员工平均工资'
    FROM emp
    WHERE salary > 8000
    GROUP BY dept;
    ```
*   **细节解释:**
    1.  `WHERE salary > 8000`: 先把工资低于或等于 $8000$ 的员工过滤掉。只有工资大于 $8000$ 的员工会进入下一步。
    2.  `GROUP BY dept`: 然后对这些筛选出来的“高薪”员工，再按照他们的部门进行分组。
    3.  `AVG(salary)`: 计算每个部门内，这些“高薪”员工的平均工资。
*   **与上一个例子的对比:**
    *   上一个例子 (`HAVING AVG(salary) > 8500`) 是先计算所有员工在各部门的平均工资，然后筛选出平均工资大于 $8500$ 的部门。
    *   这个拓展例子 (`WHERE salary > 8000`) 是先筛选出工资大于 $8000$ 的员工，然后用这些员工去计算他们所在部门的平均工资。
    *   这两个例子的结果和含义是完全不同的，清楚地展示了 `WHERE` (事前过滤行) 和 `HAVING` (事后过滤组) 的区别。

### 1.4.6 ### 案例4: 查询每个部门所有员工的姓名
*   **通俗概括:** 我们想知道每个部门里都有哪些员工，并把他们的名字（可能很多个）都列出来显示在同一格里。
*   **老师指出的问题:** 如果直接写 `SELECT dept, name FROM emp GROUP BY dept;` 会报错或结果无意义。
    *   **原因:** `GROUP BY dept` 后，每个部门组内可能有多条员工记录， وبالتالي 就会有多个 `name`。数据库不知道该显示哪个 `name` (第一个？最后一个？随机一个？)。标准的SQL不允许这样做，因为 `SELECT` 列表中的非聚合列必须出现在 `GROUP BY` 子句中，除非它是聚合函数的一部分。
*   **解决方案: 使用 `GROUP_CONCAT()` 函数 (MySQL特有)**
    *   **SQL语句:**
        ```sql
        SELECT dept AS '部门', GROUP_CONCAT(name) AS '员工姓名列表'
        FROM emp
        GROUP BY dept;
        ```
    *   **细节解释:**
        1.  `GROUP_CONCAT(name)`:
            *   这是一个聚合函数，是 MySQL 提供的一个非常实用的功能。
            *   它会把每个部门分组内的所有 `name` 值连接起来，默认用逗号 `,` 分隔，形成一个单一的长字符串。
            *   **来源:** `GROUP_CONCAT()` 是 MySQL 特有的一个聚合函数。其他数据库可能有类似功能的函数，例如 PostgreSQL 中的 `STRING_AGG()` 或 Oracle 中的 `LISTAGG()`。
        2.  `AS '员工姓名列表'`: 给这个拼接好的员工姓名长字符串起个别名。
*   **预期结果 (示例):**
    | 部门   | 员工姓名列表                      |
    | :----- | :-------------------------------- |
    | 教学部 | 张三,李四,王五                    |
    | 运营部 | 赵六,孙七                         |
    *(这里的姓名是示意，实际会是表中的真实姓名)*

### 1.4.7 ### 案例5: 查询公司一共有多少个员工
*   **通俗概括:** 我们想知道公司总共有多少名员工。
*   **SQL语句:**
    ```sql
    SELECT COUNT(*) AS '总员工数'
    FROM emp;
    ```
*   **细节解释:**
    1.  `COUNT(*)`: 统计 `emp` 表中的总行数。
    2.  因为没有 `GROUP BY` 子句，所以 `COUNT(*)` 会作用于整张表，把所有记录视为一个大组进行统计。
*   **预期结果 (示例):**
    | 总员工数 |
    | :------- |
    | $32$     |

### 1.4.8 ### 案例6: 查询每年出生的员工数，并按人数降序排序
*   **通俗概括:** 我们想知道每年（比如1999年、1992年等）分别有多少员工出生，并且想看哪个年份出生的人最多。
*   **SQL语句:**
    ```sql
    SELECT
        YEAR(birthday) AS '出生年份',
        COUNT(*) AS '人数'
    FROM emp
    GROUP BY YEAR(birthday)
    ORDER BY '人数' DESC;
    -- 老师视频中可能用了一个更短的别名，比如 COUNT(*) AS c, 然后 ORDER BY c DESC;
    -- SELECT YEAR(birthday) AS year_of_birth, COUNT(*) AS num_employees FROM emp GROUP BY year_of_birth ORDER BY num_employees DESC;
    ```
*   **细节解释:**
    1.  `YEAR(birthday) AS '出生年份'`:
        *   `YEAR()`: 这是一个日期/时间函数，用于从一个日期或日期时间类型的值中提取出年份部分。
            *   **来源:** `YEAR()` 是 SQL 中标准或非常常见的日期处理函数。类似的还有 `MONTH()`, `DAY()`, `HOUR()`, `MINUTE()`, `SECOND()` 等，用于提取日期的不同部分。
        *   `birthday`: 假设 `emp` 表中有一个 `birthday` 字段，存储员工的出生日期。
        *   `AS '出生年份'`: 给提取出来的年份起个别名。
    2.  `COUNT(*) AS '人数'`: 统计每个组（即每年）有多少人。
    3.  `FROM emp`: 数据来源。
    4.  `GROUP BY YEAR(birthday)`: 按照员工出生日期的年份进行分组。所有在同一年出生的员工会归为一组。
    5.  `ORDER BY '人数' DESC`:
        *   `ORDER BY`: 用于对最终的查询结果进行排序。
        *   `'人数'`: 指定按照我们之前定义的别名“人数”（即 `COUNT(*)` 的结果）进行排序。
        *   `DESC`: 是 `DESCENDING` (降序) 的缩写，表示从多到少排序。如果想从少到多，用 `ASC` (`ASCENDING`，升序)，`ASC` 也是默认的排序方式。
*   **预期结果 (示例):**
    | 出生年份 | 人数 |
    | :------- | :--- |
    | $1999$   | $13$ |
    | $1990$   | $5$  |
    | ...      | ...  |
    | $1986$   | $1$  |

### 1.4.9 ### 案例7: 查询公司所有员工的平均工资
*   **通俗概括:** 计算公司里所有员工的平均工资是多少，把所有员工看成一个大整体。
*   **SQL语句:**
    ```sql
    SELECT AVG(salary) AS '公司平均工资'
    FROM emp;
    ```
*   **细节解释:**
    *   这个在案例2的补充里已经讲过了。`AVG(salary)` 计算 `emp` 表中所有记录的 `salary` 字段的平均值。因为没有 `GROUP BY`，所以聚合函数作用于满足 `FROM`（以及可能的 `WHERE`）条件的整个结果集。

## 1.5 ## 总结
*   **通俗概括:** 这节课我们重点学习了 `HAVING` 这个新伙伴，它专门在 `GROUP BY` 分组完成后对分组结果进行筛选，同时我们也把之前学的知识点串起来用了用，让查询更强大。
*   **核心要点:**
    1.  **`HAVING` 用于分组后的筛选:** 它是 `GROUP BY` 的搭档，对已经形成的“组”进行条件判断。
    2.  **`WHERE` 用于分组前的筛选:** 它在数据分组之前，就对原始的每一“行”数据进行条件判断。
    3.  **聚合函数的位置:** 聚合函数（如 `COUNT()`, `MAX()`, `AVG()`）可以用在 `SELECT` 列表和 `HAVING` 子句中，但不能直接用在 `WHERE` 子句中（除非是子查询）。
    4.  **执行顺序概念:** 理解大致的逻辑执行顺序 (`FROM` -> `WHERE` -> `GROUP BY` -> `HAVING` -> `SELECT` -> `ORDER BY` -> `LIMIT`) 有助于写出正确的SQL。
    5.  **别名的使用:** 在 `SELECT` 中定义的列别名，通常可以在 `HAVING`, `ORDER BY` 中使用（MySQL支持，其他数据库可能需重复表达式）。

希望这些详细的解释能帮助你这个小白同学理解 `HAVING` 子句以及它和 `WHERE` 的区别！多练习这些例子，很快就能掌握了！