---
aliases: [MySQL批量插入数据, 高效插入多条记录, INSERT VALUES批量, INSERT SET语法]
tags: [MySQL, SQL, 数据库入门, 数据插入, 性能优化]
date: 2024-12-18
---
# 1 MySQL从基础到进阶：批量插入数据的高效方法
> 讲师：苑昊老师
> 视频参考时间：2024-12-18 15:23:40 (这是你笔记的记录时间，实际视频发布可能更早)
## 1.1 背景回顾与本节目标
**一句话概括：** 上节课我们学会了用 `INSERT VALUES` 一次加一条数据，这节课我们要学习怎么用 `INSERT VALUES` 一次加很多条数据，并且学一个新的添加数据的方法 `INSERT SET`。
在正式开始前，老师提到了，如果现在不教特殊语法，让你添加 $100$ 条记录，你可能会想到重复写 $100$ 次单条添加的SQL语句。这引出了我们今天要解决的核心问题：**效率**。
老师还演示了在图形用户界面 (GUI) 里删除数据：
*   可以通过点击界面上的按钮（比如减号）来删除记录。
*   任何在GUI中的修改（增、删、改）都需要点击“提交 (Submit)”才能真正更新到数据库中。
*   **细节：ID的自增性**
    *   即使你删除了某些记录（比如删掉了ID为 $9$ 的记录），数据库的自增ID（如果设置了的话）在下次插入新数据时，通常会从之前达到的最大ID继续往上增（比如从 $10$ 开始），而不是去填补被删除的 $9$。它会“记住”曾经达到的最大ID。
## 1.2 提出问题：多次单条插入的弊端
**一句话概括：** 如果你想加 $100$ 条差不多的数据，写 $100$ 遍 `INSERT` 语句虽然可行，但会非常非常慢，因为电脑要和数据库“对话” $100$ 次。
假设我们有一个 `student` 表，有 `id` (自增主键), `name` (姓名), `age` (年龄) 字段。
我们要插入一条叫 'Rain'，年龄 $28$ 的学生记录。如果表的 `id` 是自增的，我们通常不需要手动指定 `id`。
单条插入语句（回顾）：
```sql
$$
INSERT INTO student (name, age) VALUES ('Rain', 28);
$$
```
*   `INSERT INTO student`: 这是告诉数据库“我要往 `student` 这张表里加东西了”。
*   `(name, age)`: 这是指定我要给哪些“列”（也叫字段）加数据。
*   `VALUES ('Rain', 28)`: 这是具体要加的值，`'Rain'` 对应 `name`，$28$ 对应 `age`。顺序要匹配。
**现在，如果我们要用“笨”办法添加 $100$ 条 'Rain' 的记录：**
你会写 $100$ 遍上面的语句：
```sql
$$
INSERT INTO student (name, age) VALUES ('Rain', 28);
INSERT INTO student (name, age) VALUES ('Rain', 28);
INSERT INTO student (name, age) VALUES ('Rain', 28);
-- ... (此处省略97条) ...
INSERT INTO student (name, age) VALUES ('Rain', 28);
$$
```
**为什么这种方式不好？**
1.  **代码冗余**：写了太多重复的代码。
2.  **性能极差（核心问题）**：
    *   老师解释道，每一条 `INSERT` 语句执行，都相当于一次“**撞击数据库 (Hit the database)**”。
    *   **“撞击数据库”是什么意思？** 想象一下，你要给朋友送 $100$ 个苹果。
        *   **慢方法**：你每次拿 $1$ 个苹果，跑到朋友家，敲门，把苹果给他，然后回家。再拿第 $2$ 个苹果，再跑过去...这样重复 $100$ 次。你花在路上的时间、敲门等待的时间会非常多。
        *   **数据库也是如此**：每执行一条 `INSERT`，数据库都要：
            1.  **解析SQL语句**：看看你写的命令对不对。
            2.  **连接和认证**：和数据库建立沟通渠道。
            3.  **查找表**：找到你要操作的 `student` 表。
            4.  **加锁（可能）**：为了保证数据一致性，可能需要短暂地“锁住”一部分资源。
            5.  **写入数据**：把数据写到磁盘上。
            6.  **返回结果**：告诉你成功了还是失败了。
    *   这整个过程，即使很快（比如视频中提到的 $2$ms、$6$ms、$4$ms），但 $100$ 次累加起来就非常可观了。如果是一万条，那简直是灾难。视频里老师演示了插入 $100$ 条，虽然数据量小，但也出现了短暂的“转圈圈”卡顿，总耗时是将每次插入的时间累加起来的。
## 1.3 解决方案：`INSERT VALUES` 批量添加
**一句话概括：** 我们可以只写一条 `INSERT` 语句，但一次性告诉数据库所有要添加的数据，这样数据库只需要“被打扰”一次，效率大大提高。
**语法格式：**
```sql
$$
INSERT INTO table_name (column1, column2, ..., columnN)
VALUES
    (value1_for_row1, value2_for_row1, ..., valueN_for_row1),
    (value1_for_row2, value2_for_row2, ..., valueN_for_row2),
    (value1_for_row3, value3_for_row3, ..., valueN_for_row3),
    -- ... 更多行的数据 ...
    (value1_for_last_row, value2_for_last_row, ..., valueN_for_last_row); -- 注意这里是分号
$$
```
*   `INSERT INTO table_name (column_list)`: 这部分和单条插入一样，指定表名和要插入的字段。
*   `VALUES`: 关键字，表明后面的是要插入的值。
*   `(value_set_1), (value_set_2), ..., (value_set_N)`:
    *   每一对小括号 `()` 代表**一行记录**的值。
    *   括号内的值要与前面 `(column_list)` 中指定的字段一一对应，顺序和数据类型都要正确。
    *   **关键点**：每组记录值（即每对小括号）之间用**逗号 `,`** 分隔。
    *   只有**最后一组记录值**的括号后面才跟**分号 `;`**，表示整条 `INSERT` 语句的结束。
**例子：一次性插入 $5$ 条学生记录**
假设我们要插入以下 $5$ 条数据：
1.  Rain1, 28岁
2.  Rain2, 29岁
3.  Rain3, 30岁
4.  Rain4, 28岁
5.  Rain5, 27岁
SQL语句如下：
```sql
$$
INSERT INTO student (name, age)
VALUES
    ('润一', 28),  -- 第一条记录的值，注意这里的逗号
    ('润二', 29),  -- 第二条记录的值，逗号
    ('润三', 30),  -- 第三条记录的值，逗号
    ('润四', 28),  -- 第四条记录的值，逗号
    ('润五', 27);  -- 最后一条记录的值，这里是分号
$$
```
*   `('润一', 28)` 对应第一行数据，`'润一'` 赋给 `name`，$28$ 赋给 `age`。
*   以此类推。
**为什么这种方式快？**
*   回到送苹果的例子：这次你把 $100$ 个苹果都装进一个大篮子里，一次性跑到朋友家，敲一次门，把整个篮子交给他，然后回家。效率是不是高多了？
*   对于数据库：
    1.  它只需要解析一次SQL语句。
    2.  只需要建立一次连接和认证。
    3.  只需要查找一次表。
    4.  可以更高效地进行批量写入操作。
*   **总结**：数据库只被“撞击”了一次，虽然这次撞击携带了更多的数据，但省去了大量的重复准备和通信时间。
*   **效果**：视频中老师演示，用这种方式插入 $100$ 条记录，只花了 $18$ms，比之前多次单条插入的总时间（比如 $100 \times 3\text{ms} = 300\text{ms}$）快了非常多。
**重要提醒：** 以后在项目中需要批量添加数据时，**强烈推荐使用这种单条 `INSERT` 语句配合多组 `VALUES` 的方式！**
## 1.4 另一种插入语法：`INSERT SET`
**一句话概括：** 除了 `INSERT VALUES`，还有一种叫 `INSERT SET` 的方法来添加单条数据，它的写法更像给变量赋值，可读性也挺好。
老师提到，插入数据主要有两种语法：
1.  `INSERT ... VALUES ...` (我们已经学了单条和批量)
2.  `INSERT ... SET ...`
**`INSERT SET` 语法格式：**
```sql
$$
INSERT INTO table_name
SET
    column1 = value1,
    column2 = value2,
    column3 = value3,
    -- ... 更多字段赋值 ...
    columnN = valueN; -- 注意这里是分号
$$
```
*   `INSERT INTO table_name`: 和之前一样，指定要操作的表。
*   `SET`: 这是关键字，表示我们要“设置”字段的值。
*   `column1 = value1, column2 = value2, ...`:
    *   这里直接用 `字段名 = 值` 的形式来指定要赋给哪个字段什么值。
    *   多个“字段=值”对之间用**逗号 `,`** 分隔。
    *   最后一个“字段=值”对后面用**分号 `;`** 结束整个语句。
    *   **优点**：字段的顺序可以随意写，不像 `VALUES` 那样必须严格按字段列表的顺序。
**例子：用 `INSERT SET` 添加一条学生记录**
我们要添加一个名叫 '苑'，年龄为 $28$ 的学生。
```sql
$$
INSERT INTO student
SET name = '苑', age = 28;
$$
```
也可以这样写，效果一样：
```sql
$$
INSERT INTO student
SET age = 28, name = '苑';
$$
```
*   `name = '苑'`：把字符串 `'苑'` 赋给 `name` 字段。
*   `age = 28`：把数字 $28$ 赋给 `age` 字段。
**`INSERT SET` vs `INSERT VALUES`**
*   **可读性**：对于单条记录，`INSERT SET` 的可读性可能更强，因为它明确指出了哪个字段对应哪个值，不容易因顺序搞错。
*   **普遍性**：老师提到，尽管 `INSERT SET` 也很直观，但在实际工作中，`INSERT INTO ... VALUES ...` 的形式用得**更加普遍**。
*   **批量插入**：`INSERT SET` 语法本身并不直接支持像 `INSERT ... VALUES (...), (...), ...;` 那样简洁高效的批量插入。如果要用 `SET` 批量插入，你还是得写多条 `INSERT SET` 语句，那就又回到了性能低下的老路上了。
**结论**：
*   添加**单条**数据：`INSERT VALUES` 和 `INSERT SET` 都可以，看个人喜好或团队规范。
*   添加**多条**数据（批量插入）：**首选且强烈推荐 `INSERT INTO ... VALUES (...), (...), ...;` 的形式。**
## 1.5 总结与展望
**一句话概括：** 这节课我们学会了两种添加数据到数据库的方法，特别是掌握了如何高效地一次性添加大量数据，下次课我们要学习更核心的“查询数据”了！
*   **回顾关键点：**
    1.  **多次单条 `INSERT VALUES`**：性能差，因为多次“撞击”数据库。
    2.  **单条 `INSERT VALUES` + 多组值**：`INSERT INTO student (name, age) VALUES ('A',10), ('B',20), ('C',30);` 这是**推荐的批量插入方式**，性能好。
    3.  **`INSERT SET`**：`INSERT INTO student SET name='D', age=40;` 适合单条插入，可读性好，但通常不用于批量。
*   **核心思想**：减少与数据库的交互次数是提升批量操作性能的关键。
*   **老师的建议**：在实际开发中，涉及到批量添加数据时，务必使用 `INSERT ... VALUES (...), (...), ...;` 的方式。
**下节课内容预告：** 学习数据库操作中最重要的部分——**查询记录 (SELECT)**。这是我们从数据库获取信息的主要手段。
希望这些详细的解释能帮助你完全理解这节课的内容！每个细节和公式的来源都尽量解释清楚了。如果有任何不明白的地方，随时可以再问！
