
# 1 【SQL数据库】SQL两小时半快速入门到精通 - 学习笔记

> 本笔记根据B站UP主“程序不打烊”的视频《【SQL数据库】SQL两小时半快速入门到精通 建议反复观看 学不会自我反省》整理，旨在帮助零基础学习者理解SQL和数据库的基本概念。

## 1.1 #1 基础观念入门 (P1)

### 1.1.1 ## 什么是资料库 (Database)？

*   **一句话概括：** 数据库本质上就是个有组织地存放信息的地方，电脑上的数据库特别擅长管理大量信息并能快速查找。
*   **详细解释：**
    *   “资料库”就是储存资料（数据、信息）的地方。
    *   **生活中的例子：**
        *   我们的大脑：可以记事，但容量有限，也可能会忘记。
        *   一本书或一张纸：可以记录文字、数字，但资料多了查找起来很慢。
        *   电脑：可以存储海量数据。
    *   **为什么用电脑做数据库？**
        *   **大容量存储：** 电脑硬盘可以存很多东西。
        *   **快速查找：** 如果数据经过了良好的组织，电脑能非常快地找到你需要的信息。
    *   **应用场景：** 游戏、网站、APP等，都需要处理大量数据，并且要求反应快。
        *   **例子：** YouTube需要存储海量的影片信息（标题、描述、上传者、观看次数等）。当你在搜索框搜索“小白”时，它需要快速从亿万影片中找出相关的。

### 1.1.2 ## 什么是资料库管理系统 (DBMS)？

*   **一句话概括：** 数据库管理系统（DBMS）是一款专门的软件，它帮我们高效地整理、存取和管理数据库里的数据，我们不用自己操心底层的复杂操作。
*   **详细解释：**
    *   把资料随便丢到电脑上并不会自动变快，需要对资料进行“整理”。
    *   这个“整理”的工作不需要我们自己做，有专门的软件来帮忙，这些软件统称为 **资料库管理系统 (Database Management System, DBMS)**。
    *   **DBMS 的作用：**
        *   **整理资料：** DBMS 会用特定的方式组织数据，使得存取更高效。
        *   **简化操作：** 我们只需要告诉DBMS想做什么（比如找数据、加数据），它就会去数据库里高效地完成。
    *   **例子 (YouTube)：**
        *   **搜索影片：** 用户在YouTube搜索“小白” -> YouTube网站程序连接到它的DBMS -> DBMS告诉数据库“我要找关于小白的影片” -> DBMS从（已经整理好的）数据库中快速找出影片。
        *   **上传影片 (新增资料)：** 用户上传影片 -> YouTube网站程序连接到DBMS -> DBMS告诉数据库“我要新增一条影片资料” -> DBMS高效地把影片信息加入数据库。
        *   **修改影片信息 (修改资料)：** 类似。
        *   **删除影片 (删除资料)：** 类似。

### 1.1.3 ## 资料库的种类

*   **一句话概括：** 数据库主要分为两大类：一种是像Excel表格一样结构清晰、表与表之间能关联的“关系型数据库”，另一种则是存储方式更灵活多样的“非关系型数据库”。
*   **详细解释：**
    *   不同的DBMS整理资料的方式不同，所以它们的“资料库”看起来也不一样。
    *   主要分为两大主流类型：

    1.  **关联式资料库 (Relational Database)**
        *   也叫 **SQL资料库** (SQL可以读作 "See-क्वल")。
        *   **储存方式：** 把资料存放在一个一个的 **表格 (Table)** 里，类似于Excel表格。
        *   **核心特点：** 这些表格之间可以建立“关联”，把不同表格的数据联系起来。 (后面会详细讲)
        *   **代表软件 (RDBMS - Relational Database Management System 关系型数据库管理系统)：**
            *   MySQL (本课程使用)
            *   Oracle
            *   PostgreSQL (常读作 "Post-gress-Q-L")
            *   SQL Server (微软的产品)
            *   SQLite (轻量级，常用于移动应用)
        *   这些软件就是 **关联式资料库管理系统 (RDBMS)**。

    2.  **非关联式资料库 (Non-Relational Database)**
        *   也叫 **NoSQL** (可以理解为 "Not Only SQL" 不仅仅是SQL，或者 "No SQL" 不要SQL)。
        *   **储存方式：** 只要不是用关系型数据库那种表格方式储存的，基本都算这类。存储方式非常多样：
            *   **文件式 (Document)：** 把数据存成类似JSON或XML的文档格式 (如 MongoDB)。
            *   **键值对 (Key-Value)：** 用一个唯一的“键”对应一个“值”来存储 (如 Redis)。
            *   **图形 (Graph)：** 用点和边来表示数据和它们之间的关系 (如 Neo4j)。
            *   还有列式存储、对象存储等。
        *   **代表软件 (NRDBMS - Non-Relational Database Management System 非关系型数据库管理系统，虽然这个缩写不常用)：**
            *   MongoDB
            *   Redis
            *   DynamoDB (亚马逊AWS的服务)
            *   Elasticsearch (常用于搜索)
        *   这些软件就是 **非关联式资料库管理系统**。

### 1.1.4 ## 什么是SQL？

*   **一句话概括：** SQL是一种专门用来和“关系型数据库管理系统”沟通的语言，通过它，我们可以命令数据库做事，比如查询、添加、修改或删除数据。
*   **详细解释：**
    *   **SQL全称：** Structured Query Language (结构化查询语言)。
    *   **关键点：** “语言”。SQL是一种计算机语言。
    *   **沟通对象：** SQL是专门用来和 **关联式资料库管理系统 (RDBMS)** (如MySQL, Oracle等) 进行沟通的语言。
    *   **例子 (YouTube使用MySQL)：**
        *   用户搜索“小白” -> YouTube网站程序连接到MySQL (一个RDBMS) -> YouTube程序用 **SQL语言** 告诉MySQL：“请帮我从数据库里找出关于‘小白’的影片”。
        *   MySQL听懂了SQL指令，就去数据库执行操作。
    *   **总结：** SQL是程序员用来操作关系型数据库（如增删改查数据、创建数据库/表、设定权限等）的标准化语言。
    *   **NoSQL的语言：** 非关系型数据库没有统一的沟通语言，每种NoSQL数据库通常有自己的一套操作方式或API (应用程序编程接口)。例如，操作MongoDB要用MongoDB的查询语法，操作Redis要用Redis的命令。

### 1.1.5 ## 课程目标总结

*   **一句话概括：** 这门课的目标是学习SQL语言，学会之后就能跟各种关系型数据库管理系统（比如MySQL）打交道，让它们帮我们管理数据。
*   **详细解释：**
    *   本课程学习 **SQL语言**。
    *   学会SQL后，可以与 **关系型数据库管理系统 (RDBMS)** 沟通。
    *   可以命令RDBMS做以下事情：
        *   创建资料库 (Database)
        *   在资料库中创建表格 (Table)
        *   查询资料 (SELECT)
        *   新增资料 (INSERT)
        *   修改资料 (UPDATE)
        *   删除资料 (DELETE)
        *   设定资料权限等。
    *   了解这些基本概念非常重要，能帮助你明白你到底在学什么。

## 1.2 #2 用MySQL学习SQL语言 (P2 - Windows & P3 - macOS)

### 1.2.1 ## 为什么选用MySQL？

*   **一句话概括：** 我们选择用MySQL来学习SQL，主要是因为它免费、流行，并且功能强大足够入门。
*   **详细解释：**
    *   市面上有很多种关系型数据库管理系统 (RDBMS)。
    *   选择 **MySQL** 的原因：
        1.  **免费版本：** MySQL Community Server 是免费的，适合学习和中小型应用。
        2.  **受欢迎：** MySQL 是世界上最流行的开源关系型数据库之一，社群庞大，资料丰富。
*   **重要提醒：SQL语法的微小差异**
    *   虽然SQL是标准语言，但不同的RDBMS (如MySQL, Oracle, SQL Server) 在SQL语法上可能会有 **细微的差别**。
    *   不过不用太担心，基础的核心语法是 **基本一样** 的。学会了MySQL的SQL，切换到其他RDBMS时，只需要适应一些小的方言差异。

### 1.2.2 ## 安装MySQL (Windows 版 - 参考P2)

*   **一句话概括：** 在Windows上安装MySQL，主要是通过官网下载一个安装包，然后选择自定义安装我们课程需要的核心组件。
*   **详细步骤 (根据视频P2)：**
    1.  **搜索：** 在浏览器搜索 "mysql community download"。
    2.  **下载页面：** 进入MySQL Community Downloads页面。
    3.  **选择安装器：** 选择 "MySQL Installer for Windows"。
    4.  **下载：** 点上面那个较大的下载按钮 (通常是 `mysql-installer-web-community` 或 `mysql-installer-community`)。
    5.  **跳过登录：** 在询问是否登录或注册Oracle账户时，点击 "No thanks, just start my download."
    6.  **运行安装程序：** 下载完成后，运行 `.msi` 安装文件。
    7.  **选择安装类型：**
        *   预设会安装很多用不到的东西。
        *   选择 **"Custom" (自定义安装)**。点 "Next"。
    8.  **选择组件 (核心)：**
        *   **MySQL Servers** -> MySQL Server -> MySQL Server 8.0 (或最新稳定版) -> 选择最上面的具体版本，点箭头 `>` 添加到右边 "Products To Be Installed"。
        *   **Applications** -> MySQL Workbench -> MySQL Workbench 8.0 (或最新版) -> 选择最上面的，点箭头 `>` 添加。 (Workbench是图形化管理工具)
        *   **Applications** -> MySQL Shell -> MySQL Shell 8.0 (或最新版) -> 选择最上面的，点箭头 `>` 添加。 (Shell是命令行工具)
    9.  **点 "Next"，然后 "Execute"** 开始安装所选组件。等待安装完成。
    10. **点 "Next"，进行产品配置：**
        *   一直点 "Next" 使用默认配置 (Type and Networking, Authentication Method)。
    11. **设置管理员密码：**
        *   在 "Accounts and Roles" 步骤，会要求输入 `root` 用户 (数据库最高管理员) 的密码。
        *   **输入两次你想要的密码，务必记住这个密码！** 之后连接数据库会用到。
        *   可以暂时不用添加其他用户。
    12. **点 "Next"，继续默认配置** (Windows Service, Server File Permissions)。
    13. **点 "Execute"** 应用配置。
    14. **点 "Finish"，"Next"，"Finish"** 完成安装。
    15. **MySQL Workbench 启动：**
        *   安装完成后，MySQL Workbench 可能会自动启动。如果没启动，可以从开始菜单搜索 "MySQL Workbench" 打开它。
        *   Workbench界面上通常会有一个预设的连接，名为 "Local instance MySQL80" (或类似)。
        *   双击这个连接，输入你之前设置的 `root` 密码，即可连接到MySQL服务器。
        *   就可以在打开的查询窗口写SQL指令了。
    16. **如果预设连接没有出现或想新建连接：**
        *   点击 Workbench 主界面上 "MySQL Connections" 旁边的 `+` 号。
        *   **Connection Name:** 给连接起个名字，比如 `my_local_sql`。
        *   其他参数 (Hostname: `127.0.0.1` 或 `localhost`, Port: `$3306$`, Username: `root`) 通常是默认的，不用改。
        *   点击 **"Test Connection"**，输入 `root` 密码，如果成功会提示 "Successfully made the MySQL connection"。
        *   点 "OK" 保存连接。然后双击新建的连接即可进入。

### 1.2.3 ## 安装MySQL (macOS 版 - 参考P3)

*   **一句话概括：** 在macOS上安装MySQL，也是从官网下载针对macOS的安装包，安装Server和图形化工具Workbench，并设置管理员密码。
*   **详细步骤 (根据视频P3)：**
    1.  **搜索：** 在浏览器搜索 "mysql community download"。
    2.  **下载页面：** 进入MySQL Community Downloads页面。
    3.  **选择 MySQL Community Server：** 点击 "MySQL Community Server"。
    4.  **选择操作系统和CPU架构：**
        *   **Operating System:** 自动选择 macOS。
        *   **OS Version:** 根据你的CPU选择：
            *   Apple M系列芯片 (M1, M2, M3...): 选择 **ARM 64-bit**。
            *   Intel芯片: 选择 **x86, 64-bit**。
            *   **如何查看CPU类型：** 点击屏幕左上角苹果Logo -> "关于本机" -> "概览" -> "处理器" 或 "芯片"。
        *   下载 `.dmg` 安装文件 (通常是第一个)。
    5.  **跳过登录：** 点击 "No thanks, just start my download."
    6.  **安装 Server：**
        *   下载完成后，打开 `.dmg` 文件，双击里面的 `.pkg` 安装包。
        *   允许安装。一路点击 "继续"、"同意"、"安装"。
        *   输入你的电脑用户密码授权安装。
    7.  **配置密码加密方式：**
        *   在 "Configuration" 步骤，选择 "Use Strong Password Encryption" (推荐)。点 "Next"。
    8.  **设置管理员密码：**
        *   输入 `root` 用户的密码，并确认。**务必记住这个密码！**
        *   (可选) "Start MySQL Server once installation is complete" 可以勾选。
        *   点 "Finish"。再次输入电脑用户密码。
    9.  **安装 MySQL Workbench (图形化工具)：**
        *   回到 MySQL Community Downloads 页面。
        *   找到 "MySQL Workbench"。
        *   下载对应 macOS 的 `.dmg` 文件。
        *   打开 `.dmg` 文件，将 MySQL Workbench 图标拖拽到 "Applications" (应用程序) 文件夹中。
    10. **首次打开 Workbench：**
        *   从 "应用程序" 文件夹或使用 Spotlight (Command + 空格) 搜索 "MySQL Workbench" 打开。
        *   如果提示 "无法打开MySQL Workbench，因为无法验证开发者"，在 "应用程序" 中找到 Workbench，右键点击 -> "打开"，然后在弹出的对话框中再点 "打开"。
    11. **连接到 MySQL Server：**
        *   Workbench 启动后，通常会有一个预设的连接 "Local instance MySQL80" (或类似)。
        *   双击它，输入之前为 `root` 用户设置的密码，即可连接。
    12. **如果预设连接没有出现或想新建连接：**
        *   点击 Workbench 主界面上 "MySQL Connections" 旁边的 `+` 号。
        *   **Connection Name:** 比如 `my_mac_sql`。
        *   **Connection Method:** Standard (TCP/IP)。
        *   **Parameters:**
            *   Hostname: `127.0.0.1` (或 `localhost`)
            *   Port: `$3306$`
            *   Username: `root`
        *   点击 **"Store in Keychain..."** 可以保存密码，下次不用输。输入 `root` 密码。
        *   点击 **"Test Connection"**。如果成功，点 "OK" 保存连接。
        *   然后双击新建的连接进入。

### 1.2.4 ## Workbench 界面简介

*   **一句话概括：** MySQL Workbench 提供了一个图形界面，让我们能方便地连接到MySQL服务器，并通过写SQL命令来操作数据库，它的界面可以根据需要调整。
*   **详细解释：**
    *   连线进来后，会看到一个可以写SQL指令的区域。
    *   **界面调整：** 右上角有一些小图标，可以用来显示/隐藏左边、右边或下面的面板。
        *   本课程主要在中间的SQL编辑区写代码，所以可以先把左边 (Navigator/Schemas) 和右边 (Context Help/Snippets) 的面板收起来，让编辑区更大。下面的 "Output" 面板显示执行结果，需要保留。
    *   **执行SQL指令：**
        *   写好SQL指令后，可以选中要执行的指令。
        *   点击工具栏上的 **黄色闪电图标 (Execute selected portion of the script)** 来执行选中的SQL。
        *   还有一个 **闪电图标带个小光标 (Execute the statement under the keyboard cursor)**，它会执行当前光标所在行的那一句SQL指令 (以分号`;`为界)。

## 1.3 #3 关联式资料库如何储存资料 (P4)

*   **一句话概括：** 关系型数据库把数据存储在一张张类似Excel的“表格”里，并通过在表格中设置特殊的“键”（Key），来实现表格间的数据关联以及更清晰地理解表内数据。
*   **详细解释：**
    *   之前提到，关联式资料库把资料储存在 **表格 (Table)** 中。
    *   表格中可以设定 **键 (Key)**，Key有两种主要作用：
        1.  让表格和表格之间产生关联。
        2.  帮助我们更了解这个表格里的资料。

### 1.3.1 ## 表格 (Table) 的结构

*   **一句话概括：** 表格就像Excel表，由行和列组成，每一行代表一条完整的记录，每一列代表记录的一个属性。
*   **详细解释：**
    *   **例子：学生资料表 (Student Table)**
        *   可以创建一个表格来存学生的资料。
        *   **属性 (Columns/列)：** 每一列代表一个属性，比如 `student_id` (学生ID), `name` (学生名字), `major` (学生主修专业)。
        *   **资料/记录 (Rows/行)：** 每一行代表一笔完整的资料（一个学生的信息）。
            *   `$1$`, 小黑, 生物
            *   `$2$`, 小白, 历史
            *   ... 总共$5$笔资料。
        *   可以新增更多行 (更多学生) 或更多列 (更多属性，如电话号码、性别)。

### 1.3.2 ## 主键 (Primary Key, PK)

*   **一句话概括：** 主键（Primary Key）是表里一个特殊的字段，它的值在每一行都必须是独一无二的，就像每个人的身份证号一样，能确保我们准确找到某一条记录。
*   **详细解释：**
    *   **作用：** 用来 **唯一标识** 表中的每一笔资料 (每一行)。
    *   **例子 (Student Table)：**
        *   可以将 `student_id` 设为 **主键 (Primary Key)**。
        *   这意味着 `student_id` 的值（如$1, 2, 3, 4, 5$）在表中不能重复。
        *   **为什么需要主键？** 假设有两条记录：
            *   ($2$, 小白, 历史)
            *   ($X$, 小白, 历史)
            如果只看名字和主修，这两条记录可能一样。但如果 `student_id` 是主键，那么 `$2$` 和 `$X$` 必须不同，这样就能区分这两条“小白”的记录。
        *   **好处：** 查询特定资料时，根据主键查最准确，因为主键能唯一确定一条记录。不会根据 `name` 查，因为名字可能重复。
    *   **视频中的标记：** 橘色背景 + 底线 表示 Primary Key。
    *   **例子 (用户账户表 - User Account Table)：**
        *   属性：`email`, `password`, `create_date`, `gender`
        *   可以将 `email` 设为 Primary Key，因为每个用户的Email是唯一的。

### 1.3.3 ## 外键 (Foreign Key, FK)

*   **一句话概括：** 外键（Foreign Key）是一个表中的字段，它指向另一个表的主键，从而在两个表之间建立起联系，让我们能把不同表的数据关联起来看。
*   **详细解释：**
    *   **作用：** 让表格和表格之间产生 **关联 (Relationship)**。
    *   **如何工作：** 一个表中的外键列，其值对应到 **另一个表格的主键 (Primary Key)** 列的值。
    *   **例子 (公司员工和部门)：**
        1.  **员工表 (Employee Table):**
            *   属性：`emp_id` (员工ID, **PK**), `name`, `birthday`, `sex`, `salary`
        2.  **部门表 (Branch Table):**
            *   属性：`branch_id` (部门ID, **PK**), `branch_name` (部门名称)
        *   **问题：** 如何知道某个员工属于哪个部门？
        *   **解决方案：** 在 **员工表 (Employee)** 中新增一个属性，比如 `branch_id`，并将其设为 **外键 (Foreign Key)**，让它 **对应到部门表 (Branch) 的主键 `branch_id`**。
            *   员工表现在是：`emp_id` (PK), `name`, ..., `salary`, `branch_id` (FK, 指向 Branch.branch_id)
            *   例如，员工小黄 (`emp_id`=$206$) 的 `branch_id` 是 `$1$`。我们去部门表找 `branch_id` 为 `$1$` 的记录，发现是“研发部门”。所以小黄是研发部门的。
        *   **关键：外键必须对应到另一个表的主键。**
            *   **为什么？** 如果外键对应到的不是主键，那么那个列的值可能重复。比如，如果部门表中的 `branch_id` 不是主键，可能存在多个 `branch_id` 为 `$1$` 的部门，那小黄到底属于哪个部门就混乱了。
    *   **视频中的标记：** 绿色背景 表示 Foreign Key。
    *   **更多例子：**
        *   **部门经理是谁？**
            *   在 **部门表 (Branch)** 中新增一个属性 `manager_id` (经理ID)，设为 **FK**，让它 **对应到员工表 (Employee) 的主键 `emp_id`**。
            *   部门表现在是：`branch_id` (PK), `branch_name`, `manager_id` (FK, 指向 Employee.emp_id)
            *   例如，研发部门 (`branch_id`=$1$) 的 `manager_id` 是 `$206$`。我们去员工表找 `emp_id` 为 `$206$` 的记录，发现是小黄。所以研发部门的经理是小黄。
        *   **员工的主管是谁？(外键指向自己表的主键)**
            *   在 **员工表 (Employee)** 中新增一个属性 `sup_id` (主管ID，Supervisor ID)，设为 **FK**，让它 **对应回员工表 (Employee) 自己的主键 `emp_id`**。
            *   员工表现在是：`emp_id` (PK), `name`, ..., `salary`, `branch_id` (FK), `sup_id` (FK, 指向 Employee.emp_id)
            *   例如，小绿 (`emp_id`=$207$) 的 `sup_id` 是 `$206$`。我们回头在员工表里找 `emp_id` 为 `$206$` 的记录，是小黄。所以小绿的主管是小黄。
            *   如果小黄的 `sup_id` 是 `NULL` (空值)，表示他没有主管，他是最高层。

### 1.3.4 ## 复合主键 (Composite Primary Key) 和 同时是主外键

*   **一句话概括：** 当单个字段不足以唯一标识一条记录时，可以用多个字段组合起来作为“复合主键”；同时，一个字段也可以既是主键的一部分，又是引用其他表的外键。
*   **详细解释：**
    *   **例子 (公司资料库)：**
        *   **员工表 (Employee):** `emp_id` (PK), `name`, `birth_day`, `sex`, `salary`, `branch_id` (FK->Branch.branch_id), `sup_id` (FK->Employee.emp_id)
        *   **部门表 (Branch):** `branch_id` (PK), `branch_name`, `mgr_id` (FK->Employee.emp_id)
        *   **客户表 (Client):** `client_id` (PK), `client_name`, `phone`
        *   **销售记录表 (Works_With):** 这个表记录哪个员工给哪个客户销售了多少金额。
            *   属性：`emp_id`, `client_id`, `total_sales`
            *   **问题：** 这三个属性中，哪个能唯一标识一条销售记录？
                *   `emp_id` 会重复 (一个员工可以服务多个客户)。
                *   `client_id` 会重复 (一个客户可以被多个员工服务，或者一个员工多次服务同一个客户——但这里模型是一员工一客户一总金额)。
                *   `total_sales` 肯定会重复。
            *   **解决方案：复合主键 (Composite Primary Key)**
                *   可以将 `emp_id` **和** `client_id` **组合起来** 作为主键。
                *   这意味着 `(emp_id, client_id)` 这个组合必须是唯一的。例如，不能同时出现两条 `(206, 400)` 的记录。
                *   如果两个属性组合起来还可能重复，可以用三个或更多属性作复合主键。
            *   **同时是主键和外键：**
                *   在 `Works_With` 表中：
                    *   `emp_id` 是复合主键的一部分，**同时**它也是一个 **FK**，指向 `Employee` 表的 `emp_id`。
                    *   `client_id` 是复合主键的一部分，**同时**它也是一个 **FK**，指向 `Client` 表的 `client_id`。
    *   **总结：** 数据库的表格设计可以很简单，也可以很复杂，可以有很多主键、外键，相互关联，具体取决于业务需求。

## 1.4 #4 SQL基本操作 - 创建与删除数据库 (P5)

*   **一句话概括：** 学习了如何在MySQL Workbench中通过 `CREATE DATABASE` 命令创建新的数据库，用 `SHOW DATABASES` 查看所有数据库，以及用 `DROP DATABASE` 删除指定的数据库，并了解了SQL关键字和命名规范。
*   **详细解释：**
    *   打开Workbench并连接到MySQL。
    *   收起左右栏，在中间的编辑器写SQL。
    *   **回顾：** MySQL是一个资料库管理系统 (DBMS)。我们写的SQL指令是在跟MySQL沟通，叫它做事。

### 1.4.1 ## 创建资料库 (CREATE DATABASE)

*   **一句话概括：** `CREATE DATABASE` 命令用于指示MySQL服务器新建一个空的数据库容器。
*   **SQL指令：**
    ```sql
    CREATE DATABASE sql_tutorial;
    ```
    *   `CREATE DATABASE`：这是SQL的关键字，告诉MySQL要做“创建数据库”这个动作。
    *   `sql_tutorial`：这是我们给新数据库起的名字。
    *   `;` (分号)：表示这条SQL指令的结束。**非常重要，大部分SQL指令都需要以分号结尾。**
*   **执行：** 选中这行代码，点击黄色闪电。下方Output会显示执行成功或失败。

### 1.4.2 ## 显示所有资料库 (SHOW DATABASES)

*   **一句话概括：** `SHOW DATABASES` 命令用于列出当前MySQL服务器上存在的所有数据库的名称。
*   **SQL指令：**
    ```sql
    SHOW DATABASES;
    ```
*   **执行：** 选中执行，会列出所有数据库，包括刚才创建的 `sql_tutorial` 和一些MySQL自带的系统数据库 (如 `information_schema`, `mysql`, `performance_schema`, `sys` – 这些我们暂时不用管)。

### 1.4.3 ## SQL 语法关键字 和 命名规范

*   **一句话概括：** SQL 语句中有一些特殊的“命令词”（关键字），通常大写以示区分，而我们自己给数据库、表等起的名字最好用反引号 `` ` `` 包起来以避免与关键字冲突或处理特殊字符。
*   **详细解释：**
    *   **关键字 (Keywords)：**
        *   如 `CREATE`, `DATABASE`, `SHOW`。在Workbench中通常会显示为 **蓝色**。
        *   **习惯大写：** 虽然SQL对关键字大小写不敏感 (写 `create database` 也能执行)，但通常 **约定俗成使用大写**，以提高可读性，区分关键字和自定义名称。
    *   **自定义名称 (Identifiers)：**
        *   如数据库名 `sql_tutorial`，表名，列名等。
        *   **反引号 (Backticks) `` ` ``：** 建议用一对反引号把自定义名称包起来，例如：
            ```sql
            CREATE DATABASE `sql_tutorial`;
            ```
            *   反引号在键盘上通常是 `Esc`键下方，数字`1`键左边的那个键 (英文输入法下)。
            *   **为什么要用反引号？**
                1.  **避免与关键字冲突：** 假设你想创建一个数据库，名字就叫 `database`。
                    ```sql
                    CREATE DATABASE database; -- 这里的第二个 'database' 会被误认为是关键字，导致错误
                    ```
                    如果用反引号：
                    ```sql
                    CREATE DATABASE `database`; -- 正确，MySQL知道 `database` 是个名字，不是关键字
                    ```
                2.  **允许特殊字符或空格：** 如果名字包含空格或特殊字符 (不推荐这样命名，但反引号允许)，如 `my database`，必须用反引号：`CREATE DATABASE \`my database\`;`
*   **总结规范：**
    *   SQL关键字 **大写**。
    *   自定义名称 (数据库名、表名、列名等) 用 **小写字母、数字、下划线 `_` 组合**，并用 **反引号 `` ` `` 包起来**。

### 1.4.4 ## 删除资料库 (DROP DATABASE)

*   **一句话概括：** `DROP DATABASE` 命令用于彻底删除一个指定的数据库及其包含的所有数据，这是一个危险操作，需谨慎。
*   **SQL指令：**
    ```sql
    DROP DATABASE `database_name_to_delete`;
    ```
    *   `DROP DATABASE`：关键字，表示删除数据库。
    *   `\`database_name_to_delete\``：要删除的数据库的名称。
*   **例子：**
    1.  先创建一个叫 `test_db` 的数据库：
        ```sql
        CREATE DATABASE `test_db`;
        SHOW DATABASES; -- 可以看到 test_db
        ```
    2.  删除 `test_db`：
        ```sql
        DROP DATABASE `test_db`;
        SHOW DATABASES; -- test_db 不见了
        ```
    3.  也可以删除之前创建的 `sql_tutorial`：
        ```sql
        DROP DATABASE `sql_tutorial`;
        SHOW DATABASES; -- sql_tutorial 也不见了
        ```

> **注意：** `DROP DATABASE` 是一个非常危险的操作，它会永久删除数据库和里面的所有数据，且通常无法恢复。在生产环境中要极其小心！

## 1.5 #5 创建资料库表格 (P6)

*   **一句话概括：** 在操作数据库中的表之前，首先要用 `USE` 命令选定要操作的数据库，然后了解MySQL中常用的数据类型，才能用 `CREATE TABLE` 命令根据设计的属性和数据类型创建表。
*   **详细解释：**
    *   上一节课创建了数据库，现在要在数据库里创建表格来存数据。

### 1.5.1 ## 选择要使用的资料库 (USE)

*   **一句话概括：** `USE` 命令告诉MySQL接下来所有的表操作（如创建表、查询表）都针对哪个数据库进行。
*   **原因：** 一个MySQL服务器上可以有很多个数据库，你需要明确告诉它你要在哪个数据库里建表。
*   **SQL指令：**
    ```sql
    -- 先重新创建上一节课删除的 sql_tutorial 数据库，如果它不存在的话
    CREATE DATABASE IF NOT EXISTS `sql_tutorial`; -- IF NOT EXISTS 表示如果不存在才创建，避免报错

    USE `sql_tutorial`;
    ```
    *   `USE`：关键字。
    *   `\`sql_tutorial\``：要使用的数据库名称。
*   **执行：** 执行后，Workbench的活动Schema（在左侧导航栏，如果显示的话）可能会加粗显示 `sql_tutorial`，表示当前操作对象是它。

### 1.5.2 ## MySQL 资料形态 (Data Types)

*   **一句话概括：** 在创建表时，必须为每个属性（列）指定一种数据类型，它规定了该列能存储什么样的数据（如整数、文字、日期等）以及如何存储。
*   **详细解释：** 创建表格时，要为每个属性（列）设定它能存储的数据的类型。这里介绍几种最常见的：
    1.  **`INT` (或 `INTEGER`)**
        *   **用途：** 存放整数。
        *   **例子：** `$0$`, `$123$`, `$-45$`。
    2.  **`DECIMAL(M, D)`**
        *   **用途：** 存放精确的小数 (浮点数)。常用于金额等需要精确计算的场景。
        *   **参数：**
            *   `M`：总位数 (整数部分 + 小数部分，不包括小数点本身和负号)。
            *   `D`：小数点后面占几位。
        *   **例子：**
            *   `DECIMAL(5, 2)`：表示总共最多$5$位数，其中小数部分占$2$位。可以存 `-999.99` 到 `999.99` 之间的数。如 `$123.45$` (共5位，小数2位)，`$2.33$` (写作 `DECIMAL(3,2)` 时，总共3位，小数2位)。
    3.  **`VARCHAR(M)`**
        *   **用途：** 存放可变长度的字符串 (文字)。
        *   **参数：**
            *   `M`：代表这个字符串 **最多** 能存放多少个 **字符** (不是字节)。
        *   **例子：**
            *   `VARCHAR(10)`：最多存$10$个字符。存 "Hello" (5个字符) 是可以的，存 "你好世界abc" (6个字符) 也是可以的。实际占用的存储空间根据实际字符长度变化。
            *   名字通常用 `VARCHAR(20)` 或 `VARCHAR(50)`。
            *   **注意：** `M` 的选择要合理，不要设太大浪费声明空间 (虽然实际占用是可变的，但定义过大也有性能影响)，也不要太小导致存不下。
    4.  **`BLOB` (Binary Large Object)**
        *   **用途：** 存放二进制的大对象数据。
        *   **例子：** 图片文件、音视频文件、其他任意类型的二进制文件。
        *   **注意：** 通常不推荐直接把非常大的文件存在数据库的BLOB字段里，可能会影响数据库性能。更常见的做法是把文件存在文件系统或对象存储服务 (如AWS S3) 里，数据库里只存文件的路径或URL。
    5.  **`DATE`**
        *   **用途：** 存放日期。
        *   **格式：** `'YYYY-MM-DD'` (年-月-日)。
        *   **例子：** `'2021-08-08'` (注意日期值作为字符串要用单引号括起来)。
    6.  **`TIMESTAMP`**
        *   **用途：** 存放时间戳，通常包含日期和时间，精确到秒。
        *   **格式：** `'YYYY-MM-DD HH:MM:SS'` (年-月-日 时:分:秒)。
        *   **例子：** `'2024-05-17 20:30:00'`。
        *   **常见用途：** 记录某条数据是什么时候被创建的 (`created_at`) 或最后修改的 (`updated_at`)。

### 1.5.3 ## 创建表格 (CREATE TABLE)

*   **一句话概括：** `CREATE TABLE` 命令用于在当前选定的数据库中，根据指定的表名、列名、数据类型和约束（如主键）来定义并创建一个新的空表。
*   **SQL指令结构：**
    ```sql
    CREATE TABLE `table_name` (
        `column1_name` DATATYPE_FOR_COLUMN1 [CONSTRAINTS_FOR_COLUMN1],
        `column2_name` DATATYPE_FOR_COLUMN2 [CONSTRAINTS_FOR_COLUMN2],
        ...
        `columnN_name` DATATYPE_FOR_COLUMNN [CONSTRAINTS_FOR_COLUMNN],
        [TABLE_LEVEL_CONSTRAINTS] -- 比如定义复合主键
    );
    ```
*   **例子：创建一个 `student` 表**
    *   表结构设计：
        *   `student_id` (学生ID): 整数, 主键
        *   `name` (姓名): 字符串, 最多$20$字符
        *   `major` (主修): 字符串, 最多$20$字符
    *   **SQL指令：**
        ```sql
        CREATE TABLE `student` (
            `student_id` INT PRIMARY KEY,
            `name` VARCHAR(20),
            `major` VARCHAR(20)
        );
        ```
        *   `CREATE TABLE \`student\``：创建名为 `student` 的表。
        *   小括号 `()` 内定义表的列。
        *   `\`student_id\` INT PRIMARY KEY`：定义 `student_id` 列，数据类型是 `INT`，并且它是 `PRIMARY KEY` (主键)。
        *   `\`name\` VARCHAR(20)`：定义 `name` 列，数据类型是 `VARCHAR`，最大长度$20$。
        *   `\`major\` VARCHAR(20)`：定义 `major` 列，同上。
        *   每个列定义之间用逗号 `,`隔开，最后一个列定义后 **没有** 逗号。
*   **执行：** 执行后，`student` 表就被创建在 `sql_tutorial` 数据库中了。

### 1.5.4 ## 查看表结构 (DESCRIBE / DESC)

*   **一句话概括：** `DESCRIBE` (或简写 `DESC`) 命令用于显示指定表的详细结构信息，包括列名、数据类型、是否允许为空、键信息等。
*   **SQL指令：**
    ```sql
    DESCRIBE `student`;
    -- 或者简写
    DESC `student`;
    ```
*   **执行结果：** 会显示一个表格，包含：
    *   `Field`: 列名 (如 `student_id`, `name`, `major`)
    *   `Type`: 数据类型 (如 `int`, `varchar(20)`)
    *   `Null`: 是否允许为 `NULL` (空值)。`NO`表示不允许，`YES`表示允许。主键默认不允许 `NULL`。
    *   `Key`: 键信息。`PRI` 表示主键。
    *   `Default`: 默认值。
    *   `Extra`: 额外信息 (如 `auto_increment` 稍后会讲)。

### 1.5.5 ## 删除表格 (DROP TABLE)

*   **一句话概括：** `DROP TABLE` 命令用于从数据库中彻底删除一个指定的表及其所有数据，这也是一个危险操作。
*   **SQL指令：**
    ```sql
    DROP TABLE `student`;
    ```
*   **执行：** 执行后，`student` 表就被删除了。如果再 `DESCRIBE student;` 就会报错，说表不存在。
*   **重新创建回来：** 为了后续练习，可以再次执行上面的 `CREATE TABLE \`student\` ...;` 语句。

### 1.5.6 ## 修改表结构 (ALTER TABLE)

*   **一句话概括：** `ALTER TABLE` 命令用于修改已存在表的结构，例如添加新列、删除现有列或修改列的定义。

#### 1.5.6.1 #### 新增表格属性 (ADD COLUMN)

*   **一句话概括：** 使用 `ALTER TABLE ... ADD COLUMN ...` 可以在现有表中增加一个新的列，并指定其名称和数据类型。
*   **例子：** 给 `student` 表增加一个 `gpa` (绩点) 属性，类型为小数，总共$3$位，小数$2$位。
    ```sql
    ALTER TABLE `student`
    ADD COLUMN `gpa` DECIMAL(3, 2);
    ```
    *   `ALTER TABLE \`student\``：指明要修改 `student` 表。
    *   `ADD COLUMN \`gpa\` DECIMAL(3, 2)`：添加一个名为 `gpa` 的列，数据类型是 `DECIMAL(3, 2)`。
*   **验证：**
    ```sql
    DESC `student`; -- 可以看到新增了 gpa 列
    ```

#### 1.5.6.2 #### 删除表格属性 (DROP COLUMN)

*   **一句话概括：** 使用 `ALTER TABLE ... DROP COLUMN ...` 可以从现有表中删除一个指定的列。
*   **例子：** 把刚才加的 `gpa` 列删掉。
    ```sql
    ALTER TABLE `student`
    DROP COLUMN `gpa`;
    ```
*   **验证：**
    ```sql
    DESC `student`; -- gpa 列不见了
    ```

### 1.5.7 ## Primary Key 的另一种写法 (表级约束)

*   **一句话概括：** 除了在列定义时直接声明主键（列级约束），也可以在所有列定义完之后，在表级别单独声明主键，这种方式在定义复合主键时是必需的。
*   **详细解释：**
    *   之前我们这样写主键 (列级约束)：
        ```sql
        CREATE TABLE `student_example1` (
            `student_id` INT PRIMARY KEY,
            `name` VARCHAR(20)
        );
        DROP TABLE `student_example1`; -- 清理
        ```
    *   也可以这样写 (表级约束)：
        ```sql
        CREATE TABLE `student_example2` (
            `student_id` INT,
            `name` VARCHAR(20),
            PRIMARY KEY (`student_id`) -- 在所有列定义完后，单独声明主键
        );
        DROP TABLE `student_example2`; -- 清理
        ```
    *   两种写法效果一样。表级约束的写法在定义 **复合主键** (多个列共同组成主键) 时是必需的，例如：
        `PRIMARY KEY (\`col1\`, \`col2\`)`

## 1.6 #6 存入资料 (INSERT INTO) (P7)

*   **一句话概括：** `INSERT INTO` 命令用于向指定的表中添加新的数据行，你需要提供与表中列对应的值。
*   **详细解释：**
    *   我们已经创建了 `student` 表，结构是：`student_id` (INT, PK), `name` (VARCHAR(20)), `major` (VARCHAR(20))。
    *   现在向里面存入数据。

### 1.6.1 ## 基本的 INSERT INTO 用法

*   **一句话概括：** `INSERT INTO ... VALUES ...` 的基本形式要求你按照表定义时的列顺序，为每一列提供一个值。
*   **SQL指令结构：**
    ```sql
    INSERT INTO `table_name` VALUES (value1, value2, value3, ...);
    ```
    *   `value1` 对应表的第一列，`value2` 对应第二列，以此类推。
    *   **注意：**
        *   **字符串和日期类型的值需要用单引号 `' '` 包起来。** (双引号 `" "` 在某些SQL方言中也可以，但单引号更通用)。
        *   数字类型的值直接写，不用引号。
*   **例子：向 `student` 表插入一条记录**
    *   学生信息：ID=$1$，名字=小白，主修=历史
    ```sql
    -- 确保 student 表存在并且是空的 (如果之前有数据)
    -- DROP TABLE IF EXISTS `student`;
    -- CREATE TABLE `student` (
    --    `student_id` INT PRIMARY KEY,
    --    `name` VARCHAR(20),
    --    `major` VARCHAR(20)
    -- );

    INSERT INTO `student` VALUES (1, '小白', '历史');
    ```
    *   `1` 对应 `student_id` (INT类型)
    *   `'小白'` 对应 `name` (VARCHAR类型，所以用单引号)
    *   `'历史'` 对应 `major` (VARCHAR类型，所以用单引号)
*   **查看插入结果 (SELECT *)**
    *   **一句话概括：** `SELECT * FROM table_name;` 是一个查询命令，用于显示指定表中的所有列和所有行的数据。
    *   **SQL指令：**
        ```sql
        SELECT * FROM `student`;
        ```
        *   `SELECT`：关键字，表示要查询数据。
        *   `*` (星号)：通配符，表示“所有列”。
        *   `FROM \`student\``：从 `student` 表查询。
    *   执行后，会看到刚才插入的数据。 (这个 `SELECT` 语句后面会详细讲)
*   **再插入一条记录：** ID=$2$，名字=小黑，主修=生物
    ```sql
    INSERT INTO `student` VALUES (2, '小黑', '生物');
    SELECT * FROM `student`;
    ```

### 1.6.2 ## 插入 `NULL` 值

*   **一句话概括：** 如果某一列允许为空（非主键且没有`NOT NULL`约束），并且在插入数据时你不知道该列的值或该列没有值，可以插入 `NULL` 关键字来表示“未知”或“无”。
*   **例子：** 插入学生 ID=$3$，名字=小绿，主修未知
    ```sql
    INSERT INTO `student` VALUES (3, '小绿', NULL);
    SELECT * FROM `student`;
    ```
    *   `NULL`：是一个特殊的关键字，表示空值或缺失值。**注意：`NULL` 不等于空字符串 `''` 也不等于数字 `$0$`。**
    *   执行后，小绿的 `major` 字段会显示为 `NULL`。

### 1.6.3 ## 主键约束 (Primary Key Constraint) 的体现

*   **一句话概括：** 主键的值必须唯一，如果尝试插入一条主键值与现有记录重复的数据，数据库会报错并拒绝插入。
*   **例子：** 尝试插入学生 ID=$3$ (已存在)，名字=小蓝，主修=英语
    ```sql
    INSERT INTO `student` VALUES (3, '小蓝', '英语'); -- 这会报错！
    ```
    *   执行会报错，类似 "Duplicate entry '3' for key 'student.PRIMARY'"，因为 `student_id` 是主键，值 `$3$` 已经存在了。
    *   这就是主键的唯一性约束在起作用。

### 1.6.4 ## 指定列名插入 (推荐)

*   **一句话概括：** `INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)` 允许你明确指定要为哪些列插入值，以及它们对应的顺序，这样更灵活且不易出错。
*   **SQL指令结构：**
    ```sql
    INSERT INTO `table_name` (`columnA`, `columnB`, `columnC`)
    VALUES (value_for_A, value_for_B, value_for_C);
    ```
    *   在表名后的小括号里写出要插入数据的列名。
    *   `VALUES` 后的小括号里的值的顺序，必须与前面指定的列名顺序一致。
*   **好处：**
    1.  **顺序无关：** 不用严格按照表定义的列顺序，只要列名和值对应即可。
    2.  **部分插入：** 可以只为表中的部分列提供值，其他未指定的列：
        *   如果它们有默认值 (后面讲 `DEFAULT`)，会自动填入默认值。
        *   如果它们允许 `NULL` 且没有默认值，会自动填入 `NULL`。
        *   如果它们不允许 `NULL` 且没有默认值，并且你没有提供值，则会报错。
*   **例子：** 插入学生 (名字=小蓝, 主修=英语, ID=$4$)
    ```sql
    INSERT INTO `student` (`name`, `major`, `student_id`)
    VALUES ('小蓝', '英语', 4);
    SELECT * FROM `student`;
    ```
    *   这里我们打乱了列的顺序，但因为明确指定了列名，所以插入是正确的。
*   **例子：只插入部分列**
    *   假设我们只知道学生ID ($5$) 和主修 (化学)，不知道名字 (假设 `name` 列允许 `NULL`)：
    ```sql
    -- 为了这个例子，我们先修改一下表结构，假设 name 允许 NULL (虽然通常名字不应为NULL)
    -- 假设我们有一个表叫 student_temp，name 允许 NULL
    -- DROP TABLE IF EXISTS `student_temp`;
    -- CREATE TABLE `student_temp` (
    --     `student_id` INT PRIMARY KEY,
    --     `name` VARCHAR(20) NULL, -- 明确允许 NULL
    --     `major` VARCHAR(20)
    -- );
    -- INSERT INTO `student_temp` (`major`, `student_id`) VALUES ('化学', 5);
    -- SELECT * FROM `student_temp`; -- name 字段会是 NULL

    -- 回到我们的 student 表，它的 name 目前是不允许 NULL 的 (因为没特别声明，且不是PK，但IDE可能默认NOT NULL)
    -- 如果要让 student 表的 name 允许 NULL，需要 ALTER TABLE
    -- 但视频例子中，如果只提供 major 和 student_id，name 就会是 NULL (暗示了 student 表的 name 列是允许 NULL 的，或者 Workbench 对未提供值的列默认填 NULL 如果该列允许)
    -- 假设 student 表的 name 列是可以为 NULL 的：
    INSERT INTO `student` (`major`, `student_id`)
    VALUES ('化学', 5); -- 此时，name 列会自动填入 NULL
    SELECT * FROM `student`;
    ```
    *   执行后，ID为$5$的学生的 `name` 字段会是 `NULL`。这等同于 `INSERT INTO \`student\` VALUES (5, NULL, '化学');`

## 1.7 #7 表格约束 (Constraints) (P8)

*   **一句话概括：** 约束是在创建表时为列设定的规则，用于保证数据的有效性和一致性，例如规定某列不能为空 (`NOT NULL`)、值必须唯一 (`UNIQUE`)、或提供默认值 (`DEFAULT`)。
*   **详细解释：**
    *   在 `CREATE TABLE` 时，除了数据类型，还可以给属性（列）增加一些限制/约束 (Constraints)。
    *   **先删除并重建 `student` 表，以便加入新的约束：**
        ```sql
        DROP TABLE IF EXISTS `student`; -- 如果表存在就删除
        CREATE TABLE `student` (
            `student_id` INT PRIMARY KEY, -- 主键本身就是一种约束 (唯一且非空)
            `name` VARCHAR(20) NOT NULL,  -- 姓名不能为空
            `major` VARCHAR(20) UNIQUE,   -- 主修专业必须唯一
            `graduation_year` INT DEFAULT 2025 -- 毕业年份，默认为2025
        );
        DESC `student`;
        ```
    *   这里我们给 `student` 表加了几个约束：
        *   `name VARCHAR(20) NOT NULL`: `name` 列的值 **不** 能是 `NULL`。
        *   `major VARCHAR(20) UNIQUE`: `major` 列的值在整个表中必须是 **唯一** 的，不能有重复的专业名称。
        *   `graduation_year INT DEFAULT 2025`: 如果插入数据时没有提供 `graduation_year` 的值，它会自动填充为 `$2025$`。

### 1.7.1 ## `NOT NULL` 约束

*   **一句话概括：** `NOT NULL` 约束强制列中必须有值，不允许插入或更新为 `NULL`。
*   **例子：**
    *   尝试插入一条 `name` 为 `NULL` 的记录：
        ```sql
        -- INSERT INTO `student` (`student_id`, `name`, `major`, `graduation_year`)
        -- VALUES (1, NULL, '计算机科学', 2024); -- 这会报错！
        ```
        *   执行会报错，类似 "Column 'name' cannot be null"，因为 `name` 列有 `NOT NULL` 约束。
    *   正确的插入：
        ```sql
        INSERT INTO `student` (`student_id`, `name`, `major`, `graduation_year`)
        VALUES (1, '小白', '计算机科学', 2024);
        SELECT * FROM `student`;
        ```

### 1.7.2 ## `UNIQUE` 约束

*   **一句话概括：** `UNIQUE` 约束保证列中的所有值都是唯一的，不允许出现重复值 (但通常允许多个 `NULL` 值，除非该列也是 `NOT NULL`)。
*   **例子：**
    *   我们已经插入了 `major` 为 '计算机科学' 的小白。
    *   尝试再插入一条 `major` 也是 '计算机科学' 的记录：
        ```sql
        -- INSERT INTO `student` (`student_id`, `name`, `major`, `graduation_year`)
        -- VALUES (2, '小黑', '计算机科学', 2023); -- 这会报错！
        ```
        *   执行会报错，类似 "Duplicate entry '计算机科学' for key 'student.major'" (具体的key名可能不同)，因为 `major` 列有 `UNIQUE` 约束。
    *   正确的插入 (不同 `major`)：
        ```sql
        INSERT INTO `student` (`student_id`, `name`, `major`, `graduation_year`)
        VALUES (2, '小黑', '历史学', 2023);
        SELECT * FROM `student`;
        ```

### 1.7.3 ## `DEFAULT` 约束

*   **一句话概括：** `DEFAULT` 约束为列指定一个默认值，如果在插入新行时没有为该列提供值，数据库会自动使用这个默认值。
*   **例子：**
    *   `graduation_year` 列有 `DEFAULT 2025`。
    *   插入一条记录，不指定 `graduation_year`：
        ```sql
        INSERT INTO `student` (`student_id`, `name`, `major`) -- 注意，没有提供 graduation_year
        VALUES (3, '小兰', '物理学');
        SELECT * FROM `student`;
        ```
    *   查询结果会看到小兰的 `graduation_year` 自动变成了 `$2025$`。

### 1.7.4 ## `AUTO_INCREMENT` 属性 (常用于主键)

*   **一句话概括：** `AUTO_INCREMENT` 通常用于整数类型的主键列，使得在插入新行时数据库能自动为该列生成一个唯一的、递增的序列号，我们无需手动指定。
*   **详细解释：**
    *   对于像 `student_id` 这样的主键，每次新增资料都要手动想一个不重复的ID (如 $1, 2, 3...$) 很麻烦。
    *   `AUTO_INCREMENT` 可以让MySQL自动为我们生成这个ID。
    *   **使用前提：**
        *   `AUTO_INCREMENT` 列必须是 **键** (通常是主键 `PRIMARY KEY`，或者是 `UNIQUE` 键)。
        *   一个表中只能有一个 `AUTO_INCREMENT` 列。
        *   数据类型通常是 `INT` 或其他整数类型。
*   **例子：**
    *   **先删除并重建 `student` 表，为 `student_id` 加上 `AUTO_INCREMENT`：**
        ```sql
        DROP TABLE IF EXISTS `student`;
        CREATE TABLE `student` (
            `student_id` INT PRIMARY KEY AUTO_INCREMENT, -- 加上 AUTO_INCREMENT
            `name` VARCHAR(20) NOT NULL,
            `major` VARCHAR(20) UNIQUE,
            `graduation_year` INT DEFAULT 2025
        );
        DESC `student`; -- 可以看到 Extra 列显示 auto_increment
        ```
    *   **插入数据时，可以不提供 `student_id` 的值 (或者提供 `NULL` 或 `$0$` 也可以触发自动增长，但不推荐直接给值)：**
        ```sql
        -- 插入第一条，不指定 student_id
        INSERT INTO `student` (`name`, `major`) VALUES ('张三', '数学');
        SELECT * FROM `student`; -- student_id 会自动变成 1 (或其他起始值，通常是1)

        -- 插入第二条
        INSERT INTO `student` (`name`, `major`) VALUES ('李四', '英语');
        SELECT * FROM `student`; -- student_id 会自动变成 2

        -- 插入第三条
        INSERT INTO `student` (`name`, `major`) VALUES ('王五', '化学');
        SELECT * FROM `student`; -- student_id 会自动变成 3
        ```
    *   这样就不用手动管理ID了，非常方便。

## 1.8 #8 修改与删除资料 (UPDATE, DELETE) (P9)

*   **一句话概括：** `UPDATE` 命令用于修改表中已存在记录的某些列的值，而 `DELETE` 命令用于从表中删除满足特定条件的记录行，这两个操作通常都需要配合 `WHERE` 子句来精确指定目标。
*   **准备工作：关闭安全更新模式 (Safe Updates Mode)**
    *   **一句话概括：** MySQL Workbench 默认开启了一个“安全更新模式”，它会阻止没有在 `WHERE` 子句中使用键列（如主键）的 `UPDATE` 或 `DELETE` 操作，以防止误操作修改或删除大量数据；练习时我们可以暂时关闭它。
    *   **原因：** Workbench 为了防止新手不小心执行了 `UPDATE student SET major = '物理';` (忘记写 `WHERE` 条件) 导致所有学生的专业都被改成物理，或者 `DELETE FROM student;` (忘记写 `WHERE` 条件) 导致所有学生数据被删除，所以默认要求 `UPDATE` 和 `DELETE` 的 `WHERE` 条件中必须包含键列。
    *   **关闭指令 (仅当前会话有效)：**
        ```sql
        SET SQL_SAFE_UPDATES = 0;
        ```
        *   `$0$` 表示关闭。如果想重新开启，设为 `$1$`。
        *   这个设置只对当前 Workbench 的连接会话有效，关闭 Workbench 再打开会恢复默认。
    *   **重新准备 `student` 表和数据：**
        ```sql
        DROP TABLE IF EXISTS `student`;
        CREATE TABLE `student` (
            `student_id` INT PRIMARY KEY AUTO_INCREMENT,
            `name` VARCHAR(20) NOT NULL,
            `major` VARCHAR(20),
            `score` INT -- 新增一个分数属性
        );

        INSERT INTO `student`(`name`, `major`, `score`) VALUES
        ('小白', '英语', 85),
        ('小黑', '历史', 92),
        ('小兰', '英语', 78),
        ('小黄', '生物', 88),
        ('小绿', '化学', 95);

        SELECT * FROM `student`;
        ```

### 1.8.1 ## 更新资料 (UPDATE)

*   **一句话概括：** `UPDATE` 命令用于修改表中已存在行的一个或多个列的值，通常配合 `WHERE` 子句指定要更新哪些行。
*   **SQL指令结构：**
    ```sql
    UPDATE `table_name`
    SET `column1` = new_value1, `column2` = new_value2, ...
    WHERE `condition`; -- 如果没有 WHERE，会更新表中的所有行！非常危险！
    ```
*   **例子1：把所有专业为 '英语' 的改成 '英语文学'**
    ```sql
    UPDATE `student`
    SET `major` = '英语文学'
    WHERE `major` = '英语';

    SELECT * FROM `student`; -- 小白和小兰的 major 变成了 '英语文学'
    ```
    *   `UPDATE \`student\``：要更新 `student` 表。
    *   `SET \`major\` = '英语文学'`：把 `major` 列的值设为 '英语文学'。
    *   `WHERE \`major\` = '英语'`：条件是，只对那些当前 `major` 是 '英语' 的行进行操作。
*   **例子2：把 `student_id` 为 `$3$` 的学生的 `major` 改成 '生物'**
    ```sql
    UPDATE `student`
    SET `major` = '生物'
    WHERE `student_id` = 3; -- student_id 是主键，能精确找到小兰

    SELECT * FROM `student`; -- 小兰的 major 变成了 '生物'
    ```
*   **例子3：使用 `OR` 更新多个条件的记录，把专业为 '生物' 或 '化学' 的都改成 '生化系'**
    ```sql
    UPDATE `student`
    SET `major` = '生化系'
    WHERE `major` = '生物' OR `major` = '化学';

    SELECT * FROM `student`; -- 小兰、小黄、小绿的 major 变成了 '生化系'
    ```
*   **例子4：一次更新多个属性，把 `student_id` 为 `$1$` 的学生 `name` 改成 '小灰'，`major` 改成 '物理'**
    ```sql
    UPDATE `student`
    SET `name` = '小灰', `major` = '物理' -- 多个属性用逗号隔开
    WHERE `student_id` = 1;

    SELECT * FROM `student`; -- 小白的 name 和 major 都变了
    ```
*   **例子5：不写 `WHERE` 条件 (危险操作！)**
    *   如果执行：
        ```sql
        -- UPDATE `student`
        -- SET `major` = '未定专业'; -- 这会把所有学生的 major 都改成 '未定专业'
        ```
    *   **强烈建议：执行 `UPDATE` 前，先用 `SELECT` 语句带上相同的 `WHERE` 条件检查一下，看看选中的是不是你真正想修改的记录。**
        ```sql
        -- 比如在执行上面的例子1之前，可以先运行：
        -- SELECT * FROM `student` WHERE `major` = '英语';
        -- 确认结果是小白和小兰，再执行 UPDATE。
        ```

### 1.8.2 ## 删除资料 (DELETE)

*   **一句话概括：** `DELETE FROM` 命令用于从表中删除满足特定条件的行，同样需要配合 `WHERE` 子句，否则会删除所有行。
*   **SQL指令结构：**
    ```sql
    DELETE FROM `table_name`
    WHERE `condition`; -- 如果没有 WHERE，会删除表中的所有行！非常危险！
    ```
*   **例子1：删除 `student_id` 等于 `$4$` 的学生 (小黄)**
    ```sql
    DELETE FROM `student`
    WHERE `student_id` = 4;

    SELECT * FROM `student`; -- 小黄不见了
    ```
*   **例子2：使用 `AND` 删除满足多个条件的记录，删除 `name` 为 '小灰' 并且 `major` 为 '物理' 的学生 (ID为1的小灰)**
    ```sql
    DELETE FROM `student`
    WHERE `name` = '小灰' AND `major` = '物理';

    SELECT * FROM `student`; -- 小灰不见了
    ```
*   **例子3：根据成绩删除，删除 `score` 小于 `$60$` 的学生 (假设当前没有)**
    *   为了演示，先改一个人的成绩：
        ```sql
        UPDATE `student` SET `score` = 55 WHERE `student_id` = 5; -- 把小绿的成绩改成55
        SELECT * FROM `student`;
        ```
    *   然后删除：
        ```sql
        DELETE FROM `student`
        WHERE `score` < 60;

        SELECT * FROM `student`; -- 小绿不见了
        ```
    *   这里的比较操作符可以是：`<` (小于), `>` (大于), `<=` (小于等于), `>=` (大于等于), `=` (等于), `!=` 或 `<>` (不等于)。
*   **例子4：不写 `WHERE` 条件 (极度危险！清空表数据！)**
    *   如果执行：
        ```sql
        -- DELETE FROM `student`; -- 这会删除 student 表中的所有数据！但表结构还在。
        ```
    *   **强烈建议：执行 `DELETE` 前，也先用 `SELECT` 语句带上相同的 `WHERE` 条件检查一下，看看选中的是不是你真正想删除的记录。**

## 1.9 #9 如何取得资料 (SELECT) (P10)

*   **一句话概括：** `SELECT` 是SQL中最核心、最常用的命令，用于从数据库表中检索数据，可以通过指定列名、使用 `WHERE` 子句过滤、`ORDER BY` 排序以及 `LIMIT` 限制结果数量等方式，精确地获取你需要的信息。
*   **详细解释：**
    *   `SELECT` 用于从数据库中“读取”或“查询”数据。
    *   **基本语法：**
        ```sql
        SELECT column1, column2, ... FROM table_name; -- 选择特定列
        SELECT * FROM table_name; -- 选择所有列
        ```
    *   **准备数据 (如果之前的student表被清空了)：**
        ```sql
        DROP TABLE IF EXISTS `student`;
        CREATE TABLE `student` (
            `student_id` INT PRIMARY KEY AUTO_INCREMENT,
            `name` VARCHAR(20) NOT NULL,
            `major` VARCHAR(20),
            `score` INT
        );
        INSERT INTO `student`(`name`, `major`, `score`) VALUES
        ('小白', '英语', 85), ('小黑', '历史', 92), ('小兰', '英语', 20),
        ('小黄', '生物', 88), ('小绿', '化学', 20), ('小明', '物理', 70);
        SELECT * FROM `student`;
        ```

### 1.9.1 ## 选择特定属性 (列)

*   **一句话概括：** 在 `SELECT` 关键字后明确列出你想要查看的列名，可以只获取部分数据，而不是所有列。
*   **例子：只取得所有学生的 `name` 属性**
    ```sql
    SELECT `name` FROM `student`;
    ```
*   **例子：取得所有学生的 `name` 和 `major` 属性**
    ```sql
    SELECT `name`, `major` FROM `student`; -- 多个列名用逗号隔开
    ```
    *   `*` (星号) 是选择所有列的简写。

### 1.9.2 ## 资料排序 (ORDER BY)

*   **一句话概括：** `ORDER BY` 子句用于对 `SELECT` 查询返回的结果集按照一个或多个列进行排序，默认为升序。
*   **SQL指令结构：**
    ```sql
    SELECT ... FROM ...
    ORDER BY `column_to_sort_by` [ASC | DESC];
    ```
    *   `ASC` (Ascending)：升序 (从小到大，A到Z)。这是默认的，可以省略。
    *   `DESC` (Descending)：降序 (从大到小，Z到A)。
*   **例子1：根据学生成绩 `score` 从低到高排序**
    ```sql
    SELECT * FROM `student`
    ORDER BY `score`; -- 默认是 ASC
    -- 等同于: SELECT * FROM `student` ORDER BY `score` ASC;
    ```
*   **例子2：根据学生成绩 `score` 从高到低排序**
    ```sql
    SELECT * FROM `student`
    ORDER BY `score` DESC;
    ```
*   **例子3：多列排序 (先按 `score` 降序，如果 `score` 相同，再按 `student_id` 升序)**
    ```sql
    SELECT * FROM `student`
    ORDER BY `score` DESC, `student_id` ASC; -- student_id ASC 可以省略 ASC
    -- 结果会看到，成绩相同的学生 (小兰和小绿，都是20分)，会按照 student_id 排序
    ```
    *   先按第一个 `ORDER BY` 的列排序，当该列的值相同时，再按第二个 `ORDER BY` 的列排序，以此类推。

### 1.9.3 ## 限制回传资料笔数 (LIMIT)

*   **一句话概括：** `LIMIT` 子句用于限制 `SELECT` 查询返回的记录数量，常用于分页或获取“前N条”记录。
*   **SQL指令结构：**
    ```sql
    SELECT ... FROM ...
    [WHERE ...]
    [ORDER BY ...]
    LIMIT number_of_rows;
    ```
*   **例子1：只取得前 `$3$` 笔学生资料 (顺序不保证，除非配合 `ORDER BY`)**
    ```sql
    SELECT * FROM `student`
    LIMIT 3;
    ```
*   **例子2：取得成绩最低的前 `$2$` 名学生**
    ```sql
    SELECT * FROM `student`
    ORDER BY `score` ASC -- 先按成绩升序排列
    LIMIT 2;             -- 然后取前两条
    ```
*   **例子3：取得成绩最高的前 `$3$` 名学生**
    ```sql
    SELECT * FROM `student`
    ORDER BY `score` DESC -- 先按成绩降序排列
    LIMIT 3;              -- 然后取前三条
    ```

### 1.9.4 ## 条件判断 (WHERE)

*   **一句话概括：** `WHERE` 子句用于在 `SELECT` (以及 `UPDATE`, `DELETE`) 语句中设置过滤条件，只选择或操作满足这些条件的行。
*   **SQL指令结构：**
    ```sql
    SELECT ... FROM ...
    WHERE condition;
    ```
    *   **比较运算符：** `=`, `!=` (或 `<>`), `>`, `<`, `>=`, `<=`
    *   **逻辑运算符：** `AND`, `OR`, `NOT`
*   **例子1：取得主修是 '英语' 的学生资料**
    ```sql
    SELECT * FROM `student`
    WHERE `major` = '英语';
    ```
*   **例子2：取得主修是 '英语' 并且 `student_id` 是 `$1$` 的学生资料**
    ```sql
    SELECT * FROM `student`
    WHERE `major` = '英语' AND `student_id` = 1;
    ```
*   **例子3：取得主修是 '英语' 或者 `score` 大于 `$20$` 的学生资料**
    ```sql
    SELECT * FROM `student`
    WHERE `major` = '英语' OR `score` > 20;
    ```
*   **例子4：取得 `score` 不等于 `$70$` 的学生资料**
    ```sql
    SELECT * FROM `student`
    WHERE `score` != 70;
    -- 或者
    -- SELECT * FROM `student` WHERE `score` <> 70;
    ```
*   **`WHERE` 可以和 `ORDER BY`, `LIMIT` 混用：**
    *   **执行顺序：** `FROM` -> `WHERE` -> `SELECT` -> `ORDER BY` -> `LIMIT` (这是逻辑上的顺序，数据库实际优化执行可能不同，但结果符合这个逻辑)
    *   **例子：取得 `score` 不等于 `$70$` 的学生中，按成绩降序排列的前 `$2$` 笔**
        ```sql
        SELECT * FROM `student`
        WHERE `score` != 70
        ORDER BY `score` DESC
        LIMIT 2;
        ```

### 1.9.5 ## `IN` 和 `NOT IN` 操作符

*   **一句话概括：** `IN` 操作符允许你在 `WHERE` 子句中指定一个值的列表，如果列的值匹配列表中的任何一个，则条件为真；`NOT IN` 则相反。
*   **SQL指令结构：**
    ```sql
    SELECT ... FROM ...
    WHERE `column_name` IN (value1, value2, value3, ...);
    ```
*   **例子：取得主修是 '历史'、'英语' 或 '生物' 的学生资料**
    ```sql
    SELECT * FROM `student`
    WHERE `major` IN ('历史', '英语', '生物');
    ```
    *   这等同于：
        ```sql
        -- SELECT * FROM `student`
        -- WHERE `major` = '历史' OR `major` = '英语' OR `major` = '生物';
        ```
        显然，用 `IN` 更简洁。
*   **例子：取得主修 **不是** '历史'、'英语' 或 '生物' 的学生资料**
    ```sql
    SELECT * FROM `student`
    WHERE `major` NOT IN ('历史', '英语', '生物');
    ```

> **总结：** `SELECT` 是非常强大的，这只是基础用法。随着数据库变复杂 (多表关联)，`SELECT` 语句也会更复杂。

## 1.10 #10 创建公司资料库 - 多表设计与创建 (P11)

*   **一句话概括：** 这一节通过设计和创建一个包含员工、部门、客户和销售记录的多表公司数据库，来实践更复杂的表结构定义，特别是主键(PK)和外键(FK)的设定与关联。
*   **详细解释：**
    *   要创建一个更真实一点的公司资料库，包含多个相互关联的表。
    *   先把之前练习的 `student` 表删掉 (如果存在)。
        ```sql
        DROP TABLE IF EXISTS `student`;
        USE `sql_tutorial`; -- 确保在正确的数据库操作
        ```

### 1.10.1 ## 表格设计

1.  **员工表 (Employee)**
    *   `emp_id` INT: 员工ID (**PK**)
    *   `first_name` VARCHAR(20): 名
    *   `last_name` VARCHAR(20): 姓
    *   `birth_day` DATE: 生日
    *   `sex` VARCHAR(1): 性别 ('M', 'F')
    *   `salary` INT: 薪水
    *   `branch_id` INT: 所属部门ID (**FK**, 指向 `Branch` 表的 `branch_id`)
    *   `sup_id` INT: 主管ID (**FK**, 指向 `Employee` 表自身的 `emp_id`)

2.  **部门表 (Branch)**
    *   `branch_id` INT: 部门ID (**PK**)
    *   `branch_name` VARCHAR(20): 部门名称
    *   `mgr_id` INT: 部门经理ID (**FK**, 指向 `Employee` 表的 `emp_id`)
    *   `mgr_start_date` DATE: 经理上任日期

3.  **客户表 (Client)**
    *   `client_id` INT: 客户ID (**PK**)
    *   `client_name` VARCHAR(20): 客户名称
    *   `phone` VARCHAR(20): 客户电话 (视频中这里用 `branch_id` INT FK 指向 Branch 表，暗示客户可能归属于某个分公司/部门，这里我按视频的来，但通常客户电话会是VARCHAR)
        *   根据视频的描述，客户表还有一个 `branch_id` FK，指向 `Branch.branch_id`。
        *   `client_id` INT PK, `client_name` VARCHAR(40), `branch_id` INT FK.
        *   (更正，视频中 Client 表设计是：`client_id` PK, `client_name`, `phone`. 而 Works_With 表是 `emp_id`, `client_id`, `total_sales`. 课程中的 `Client` 表并没有 `branch_id`。)
        *   按视频最终的 Company DB 图：
            *   **Client 表:** `client_id` (PK, INT), `client_name` (VARCHAR(40)), `industry` (VARCHAR(40)) (视频实际用的是 `phone`，但在P11的图上是 `industry`，我以视频中反复出现的四表图为准，即没有 `industry`，只有 `client_id`, `client_name`, `phone`)
            *   根据视频中 P11 7:00 左右创建的 Client 表：`client_id` INT PK, `client_name` VARCHAR(40), `branch_id` INT.  并且设置了 `FOREIGN KEY(branch_id) REFERENCES branch(branch_id) ON DELETE SET NULL`.
            *   OK，以视频中实际创建的SQL为准：`client_id` (INT, PK), `client_name` (VARCHAR(20)), `branch_id` (INT, FK 指向 `branch.branch_id`)

4.  **销售记录表 (Works_With)**
    *   `emp_id` INT: 员工ID (**FK**, 指向 `Employee.emp_id`)
    *   `client_id` INT: 客户ID (**FK**, 指向 `Client.client_id`)
    *   `total_sales` INT: 总销售金额
    *   **复合主键 (Composite PK):** (`emp_id`, `client_id`) 共同作为主键。

### 1.10.2 ## 创建表格的 SQL 指令

#### 1.10.2.1 创建员工表 (Employee)

```sql
CREATE TABLE `employee` (
    `emp_id` INT PRIMARY KEY,
    `first_name` VARCHAR(40),
    `last_name` VARCHAR(40), -- 视频用 fname, lname, 我用 first_name, last_name 更清晰
    `birth_day` DATE,
    `sex` VARCHAR(1),
    `salary` INT,
    `branch_id` INT, -- FK, 稍后添加约束
    `sup_id` INT     -- FK, 稍后添加约束
);
```
*   **注意：** 此时 `branch_id` 和 `sup_id` 的外键约束先不创建。
    *   `branch_id` 指向 `branch` 表，但 `branch` 表还没创建。
    *   `sup_id` 指向 `employee` 表自身，在表创建过程中自身还不存在，所以也需要后加。

#### 1.10.2.2 创建部门表 (Branch)

```sql
CREATE TABLE `branch` (
    `branch_id` INT PRIMARY KEY,
    `branch_name` VARCHAR(40),
    `mgr_id` INT, -- FK, 指向 employee.emp_id
    `mgr_start_date` DATE,
    FOREIGN KEY(`mgr_id`) REFERENCES `employee`(`emp_id`) ON DELETE SET NULL
);
```
*   `FOREIGN KEY(\`mgr_id\`) REFERENCES \`employee\`(\`emp_id\`)`: 定义 `mgr_id` 是外键，它引用 `employee` 表的 `emp_id` 列。
*   `ON DELETE SET NULL`: 这是一个外键约束的行为。如果 `employee` 表中被 `mgr_id` 引用的那条员工记录被删除了，那么 `branch` 表中对应记录的 `mgr_id` 字段会自动被设置为 `NULL`。 (这个后面P17会详细讲)

#### 1.10.2.3 为 `employee` 表补充外键约束

*   现在 `employee` 表和 `branch` 表都存在了，可以为 `employee` 表添加之前未设置的外键。
```sql
ALTER TABLE `employee`
ADD FOREIGN KEY(`branch_id`) REFERENCES `branch`(`branch_id`) ON DELETE SET NULL;

ALTER TABLE `employee`
ADD FOREIGN KEY(`sup_id`) REFERENCES `employee`(`emp_id`) ON DELETE SET NULL;
```

#### 1.10.2.4 创建客户表 (Client)

```sql
-- 视频中的 Client 表结构是 client_id, client_name, branch_id (FK)
-- 我这里按视频 P11 7:00 的建表语句来，这是最权威的
CREATE TABLE `client` (
  `client_id` INT PRIMARY KEY,
  `client_name` VARCHAR(40),
  `branch_id` INT,
  FOREIGN KEY(`branch_id`) REFERENCES `branch`(`branch_id`) ON DELETE SET NULL
);
-- 如果是视频中前面口述的 phone 而非 branch_id:
-- CREATE TABLE `client` (
--  `client_id` INT PRIMARY KEY,
--  `client_name` VARCHAR(40),
--  `phone` VARCHAR(20) -- 假设电话是字符串
-- );
-- 但后续 Works_With 表的 client_id FK 需要 client 表存在。
-- 以视频中实际建表SQL为准，Client 表有 branch_id FK。
```

#### 1.10.2.5 创建销售记录表 (Works_With)

```sql
CREATE TABLE `works_with` (
    `emp_id` INT,
    `client_id` INT,
    `total_sales` INT,
    PRIMARY KEY (`emp_id`, `client_id`), -- 复合主键
    FOREIGN KEY (`emp_id`) REFERENCES `employee`(`emp_id`) ON DELETE CASCADE,
    FOREIGN KEY (`client_id`) REFERENCES `client`(`client_id`) ON DELETE CASCADE
);
```
*   `PRIMARY KEY (\`emp_id\`, \`client_id\`)`: 定义 (`emp_id`, `client_id`) 这个组合是主键。
*   `ON DELETE CASCADE`: 这是另一种外键约束行为。如果 `employee` 表中被引用的员工记录被删除，那么 `works_with` 表中所有引用了该员工的记录也会 **连锁被删除**。同理 `client_id`。 (P17会详细讲)

### 1.10.3 ## 插入资料的顺序和问题

*   **一句话概括：** 由于外键约束的存在，向有关联的多个表插入数据时必须注意顺序，通常先插入被引用的表（没有外键或外键值可以为NULL的表），再插入引用这些表的表，否则可能因找不到外键对应的主键值而失败。
*   **尝试插入员工资料 (直接按员工表设计插入)：**
    *   员工小黄: `emp_id`=100, `first_name`='黄', `last_name`='小', `birth_day`='1980-01-01', `sex`='M', `salary`=80000, `branch_id`=1, `sup_id`=NULL (假设他是大老板)
    ```sql
    -- 错误尝试：
    -- INSERT INTO `employee` VALUES(100, '黄', '小', '1980-01-01', 'M', 80000, 1, NULL);
    -- 这会报错！因为 `branch_id`=1，它作为外键要引用 `branch` 表中 `branch_id`=1 的记录，但 `branch` 表现在是空的，没有 `branch_id`=1 的部门。
    ```
*   **问题：** 外键依赖导致插入顺序问题。
    *   `employee.branch_id` FK 指向 `branch.branch_id`。
    *   `branch.mgr_id` FK 指向 `employee.emp_id`。
    *   这是一个循环依赖的雏形，如果 `mgr_id` 不能为 `NULL` 会很麻烦。幸运的是，我们设置了 `ON DELETE SET NULL`，通常也意味着这些FK列允许 `NULL`。

*   **正确策略：**
    1.  **插入部门资料 (Branch)，但 `mgr_id` 先设为 `NULL`：** 因为 `mgr_id` 指向 `employee`，而 `employee` 此时还没有数据。
        ```sql
        INSERT INTO `branch` VALUES(1, '总部研发', NULL, NULL);
        INSERT INTO `branch` VALUES(2, '行政人事', NULL, NULL);
        INSERT INTO `branch` VALUES(3, '市场销售', NULL, NULL);
        SELECT * FROM `branch`;
        ```
    2.  **插入员工资料 (Employee)：** 现在 `branch` 表有数据了，`employee.branch_id` 可以引用它们。
        ```sql
        -- 假设员工ID从100开始
        INSERT INTO `employee` VALUES(100, 'David', 'Wallace', '1967-11-17', 'M', 250000, NULL, NULL); -- CEO, no branch, no sup
        INSERT INTO `employee` VALUES(101, 'Jan', 'Levinson', '1961-05-11', 'F', 110000, 1, 100); -- 研发主管，属于部门1，主管是100
        INSERT INTO `employee` VALUES(102, 'Michael', 'Scott', '1964-03-15', 'M', 75000, 2, 100); -- 行政主管，属于部门2，主管是100
        INSERT INTO `employee` VALUES(103, 'Angela', 'Martin', '1971-06-25', 'F', 63000, 2, 102); -- 行政员工，属于部门2，主管是102
        INSERT INTO `employee` VALUES(104, 'Kelly', 'Kapoor', '1980-02-05', 'F', 55000, 2, 102);
        INSERT INTO `employee` VALUES(105, 'Stanley', 'Hudson', '1958-02-19', 'M', 69000, 2, 102);
        INSERT INTO `employee` VALUES(106, 'Josh', 'Porter', '1969-09-05', 'M', 78000, 3, 100); -- 销售主管
        INSERT INTO `employee` VALUES(107, 'Andy', 'Bernard', '1973-07-22', 'M', 65000, 3, 106);
        INSERT INTO `employee` VALUES(108, 'Jim', 'Halpert', '1978-10-01', 'M', 71000, 3, 106);
        SELECT * FROM `employee`;
        ```
        *   注意：视频中的 `emp_id` 是从 206 开始，我这里为了和视频的 Corporate DB 图对应，调整了ID。并且，视频中的 `employee` 表的 `branch_id` 是允许 `NULL` 的（CEO David Wallace就没有部门）。
        *   按视频P11的表格数据：
            *   员工：(ID从100开始，不是206)
            *   David (100, CEO), Jan (101, Corporate, sup 100), Michael (102, Scranton, sup 100), Angela (103, Scranton, sup 102), Kelly (104, Scranton, sup 102), Stanley (105, Scranton, sup 102). (视频还有 Josh, Andy, Jim)
            *   部门：
            *   Corporate (1, mgr 101), Scranton (2, mgr 102), Stamford (3, mgr 106). (视频中 Josh Porter (106) 是 Stamford 经理)
            *   我这里简化一下，按照视频最初给的几个员工：小黄 (206), 小绿 (207), 小黑 (208), 小白 (209), 小蓝 (210).
            *   部门：研发 (1), 行政 (2), 资讯 (3).
            *   **修正员工和部门数据 (根据视频的实际数据图)：**
                ```sql
                -- 清空旧数据，如果需要
                DELETE FROM `employee`;
                DELETE FROM `branch`;

                -- 插入部门 (mgr_id 暂时为 NULL)
                INSERT INTO `branch` (`branch_id`, `branch_name`) VALUES (1, '研发');
                INSERT INTO `branch` (`branch_id`, `branch_name`) VALUES (2, '行政');
                INSERT INTO `branch` (`branch_id`, `branch_name`) VALUES (3, '资讯');

                -- 插入员工
                INSERT INTO `employee` VALUES(206, '黄', '小', '1980-01-01', 'M', 80000, 1, NULL); -- 小黄, 研发, 无主管
                INSERT INTO `employee` VALUES(207, '绿', '小', '1985-05-09', 'F', 60000, 2, 206); -- 小绿, 行政, 主管小黄
                INSERT INTO `employee` VALUES(208, '黑', '小', '1990-11-23', 'M', 50000, 3, 206); -- 小黑, 资讯, 主管小黄
                INSERT INTO `employee` VALUES(209, '白', '小', '1992-07-14', 'F', 40000, 2, 207); -- 小白, 行政, 主管小绿
                INSERT INTO `employee` VALUES(210, '蓝', '小', '1993-03-30', 'F', 45000, 3, 208); -- 小蓝, 资讯, 主管小黑
                ```
    3.  **更新 `branch` 表的 `mgr_id` 和 `mgr_start_date`：** 现在 `employee` 有数据了，可以更新部门经理了。
        ```sql
        UPDATE `branch` SET `mgr_id` = 206, `mgr_start_date` = '2000-02-09' WHERE `branch_id` = 1; -- 研发部经理小黄
        UPDATE `branch` SET `mgr_id` = 207, `mgr_start_date` = '2002-04-17' WHERE `branch_id` = 2; -- 行政部经理小绿
        UPDATE `branch` SET `mgr_id` = 208, `mgr_start_date` = '2005-08-21' WHERE `branch_id` = 3; -- 资讯部经理小黑
        SELECT * FROM `branch`;
        ```
    4.  **插入客户资料 (Client)：**
        ```sql
        -- 按视频建表 Client 有 branch_id FK
        INSERT INTO `client` VALUES(400, '张三公司', 1); -- 张三公司属于研发部门管辖
        INSERT INTO `client` VALUES(401, '李四企业', 1);
        INSERT INTO `client` VALUES(402, '王五集团', 2); -- 王五集团属于行政部门管辖
        INSERT INTO `client` VALUES(403, '赵六工厂', 3);
        INSERT INTO `client` VALUES(404, '孙七商店', 2);
        SELECT * FROM `client`;
        ```
    5.  **插入销售记录 (Works_With)：**
        ```sql
        INSERT INTO `works_with` VALUES(206, 400, 55000); -- 小黄-张三公司
        INSERT INTO `works_with` VALUES(207, 402, 120000);-- 小绿-王五集团
        INSERT INTO `works_with` VALUES(208, 403, 20000); -- 小黑-赵六工厂
        INSERT INTO `works_with` VALUES(208, 404, 27000); -- 小黑-孙七商店 (注意一个员工可以有多个客户)
        INSERT INTO `works_with` VALUES(209, 401, 7000);  -- 小白-李四企业
        INSERT INTO `works_with` VALUES(210, 402, 33000); -- 小蓝-王五集团 (注意一个客户可以有多个员工服务)
        -- 视频中的数据更多，这里只取几个例子。
        -- 视频中的 Works_With 数据：
        -- (102, 400, 55000), (102, 401, 267000), (105, 402, 22500), (107, 403, 5000), (108, 403, 12000), (105, 404, 33000), (107, 405, 26000), (102, 406, 15000), (105, 406, 130000)
        -- 我的员工ID和小黄他们不同，但逻辑一样。我用我上面定义的员工ID (206-210) 和客户ID (400-404)
        -- 确保works_with中的emp_id和client_id在各自表中存在
        SELECT * FROM `works_with`;
        ```
*   至此，公司资料库的表结构创建完毕，并且插入了初始数据。

## 1.11 #11 练习：基本查询 (P12)

*   **一句话概括：** 这一节通过几个实际的查询题目，练习使用 `SELECT` 语句从之前创建的公司数据库中提取不同维度的数据，巩固对 `SELECT`, `FROM`, `ORDER BY`, `LIMIT` 和选择特定列的理解。
*   **准备：** 确保公司资料库的表已创建并填充了数据 (如P11所示)。
    ```sql
    USE `sql_tutorial`;
    ```

### 1.11.1 ## 题目1：取得所有员工的资料

*   **SQL指令：**
    ```sql
    SELECT * FROM `employee`;
    ```
*   **解释：** `*` 代表所有列，`FROM \`employee\`` 表示从 `employee` 表查询。

### 1.11.2 ## 题目2：取得所有客户的资料

*   **SQL指令：**
    ```sql
    SELECT * FROM `client`;
    ```
*   **解释：** 类似上一题，只是换成了 `client` 表。

### 1.11.3 ## 题目3：按照薪水低到高取得员工资料

*   **SQL指令：**
    ```sql
    SELECT *
    FROM `employee`
    ORDER BY `salary` ASC; -- ASC 可以省略，因为是默认
    ```
*   **解释：** `ORDER BY \`salary\`` 表示按 `salary` 列排序。`ASC` 是升序 (低到高)。
*   **拓展：薪水高到低**
    ```sql
    SELECT *
    FROM `employee`
    ORDER BY `salary` DESC;
    ```

### 1.11.4 ## 题目4：取得薪水前三高的员工

*   **SQL指令：**
    ```sql
    SELECT *
    FROM `employee`
    ORDER BY `salary` DESC -- 先按薪水从高到低排序
    LIMIT 3;                -- 再取前面3条记录
    ```
*   **解释：**
    1.  `ORDER BY \`salary\` DESC`：确保薪水最高的在最前面。
    2.  `LIMIT 3`：只返回结果集中的前3条。

### 1.11.5 ## 题目5：取得所有员工的名字 (只要名字)

*   **SQL指令 (假设名字是 `first_name` 和 `last_name`)**
    ```sql
    SELECT `first_name`, `last_name`
    FROM `employee`;
    ```
*   **解释：** `SELECT` 后面直接列出想要的列名，而不是用 `*`。

### 1.11.6 ## 补充：`DISTINCT` - 去除重复资料

*   **一句话概括：** `DISTINCT` 关键字用在 `SELECT` 之后，列名之前，可以去除查询结果中指定列的重复行，只保留唯一的值。
*   **例子1：取得员工表中出现过的所有性别 (不重复)**
    *   不使用 `DISTINCT`：
        ```sql
        SELECT `sex` FROM `employee`; -- 可能会有重复的 'M', 'F'
        ```
    *   使用 `DISTINCT`：
        ```sql
        SELECT DISTINCT `sex` FROM `employee`; -- 只会返回 'M' 和 'F' 各一次 (如果都存在)
        ```
*   **例子2：取得员工表中所有不重复的 `branch_id`**
    ```sql
    SELECT DISTINCT `branch_id` FROM `employee`;
    ```
*   **解释：** `DISTINCT` 会作用于它后面紧跟着的列。如果是 `SELECT DISTINCT col1, col2 FROM ...`，那么只有当 `(col1, col2)` 这个组合完全相同时才被认为是重复的。

## 1.12 #12 聚合函数 (Aggregate Functions) (P13)

*   **一句话概括：** 聚合函数对一组值（通常是一列数据）执行计算，并返回单个汇总值，例如计算总数、平均值、总和、最大值或最小值。
*   **详细解释：**
    *   聚合函数通常和 `SELECT` 语句一起使用。
    *   它们作用于一组行，并为该组返回一个单一的值。
    *   常用的聚合函数：`COUNT`, `AVG`, `SUM`, `MAX`, `MIN`。

### 1.12.1 ## `COUNT()` - 计算笔数/行数

*   **一句话概括：** `COUNT()` 函数用于计算满足特定条件的行数，或表中总行数。
*   **`COUNT(*)`: 计算表中总共有几笔资料**
    *   **例子：计算员工总人数**
        ```sql
        SELECT COUNT(*) FROM `employee`;
        -- 或者给结果列起个别名
        SELECT COUNT(*) AS `total_employees` FROM `employee`;
        ```
        *   `AS \`total_employees\``：给 `COUNT(*)` 的结果列指定一个别名，叫 `total_employees`，使结果更易读。
*   **`COUNT(column_name)`: 计算指定列中 **非NULL** 值的数量**
    *   **例子：计算有多少员工有主管 (即 `sup_id` 不为 `NULL` 的员工数量)**
        ```sql
        SELECT COUNT(`sup_id`) AS `employees_with_supervisor` FROM `employee`;
        ```
        *   如果某员工的 `sup_id` 是 `NULL`，则这一行在 `COUNT(\`sup_id\`)` 时不会被计入。
*   **`COUNT(DISTINCT column_name)`: 计算指定列中 **不重复且非NULL** 值的数量**
    *   **例子：计算公司有多少个不同的部门 (基于 `employee` 表中的 `branch_id`)**
        ```sql
        SELECT COUNT(DISTINCT `branch_id`) AS `number_of_distinct_branches` FROM `employee`;
        ```
*   **配合 `WHERE` 使用：**
    *   **例子：计算出生日期在 '1970-01-01' 之后的女性员工人数**
        *   (视频中用1970年1月1号，我这里调整一下，比如1985年之后)
        ```sql
        SELECT COUNT(*) AS `female_employees_born_after_1985`
        FROM `employee`
        WHERE `birth_day` > '1985-01-01' AND `sex` = 'F';
        ```

### 1.12.2 ## `AVG()` - 计算平均值

*   **一句话概括：** `AVG()` 函数计算指定数值列中所有非 `NULL` 值的平均值。
*   **例子：计算所有员工的平均薪水**
    ```sql
    SELECT AVG(`salary`) AS `average_salary` FROM `employee`;
    ```
    *   `AVG()` 会忽略 `salary` 列中的 `NULL` 值。

### 1.12.3 ## `SUM()` - 计算总和

*   **一句话概括：** `SUM()` 函数计算指定数值列中所有非 `NULL` 值的总和。
*   **例子：计算所有员工薪水的总和**
    ```sql
    SELECT SUM(`salary`) AS `total_salary_expenses` FROM `employee`;
    ```
*   **例子：计算 "行政" 部门 (假设 `branch_id` 为 $2$) 员工薪水的总和**
    ```sql
    SELECT SUM(`salary`) AS `admin_total_salary`
    FROM `employee`
    WHERE `branch_id` = 2;
    ```

### 1.12.4 ## `MAX()` - 计算最大值

*   **一句话概括：** `MAX()` 函数找出指定列中的最大值 (对数字、字符串、日期都适用)。
*   **例子：找出公司中最高的薪水是多少**
    ```sql
    SELECT MAX(`salary`) AS `highest_salary` FROM `employee`;
    ```

### 1.12.5 ## `MIN()` - 计算最小值

*   **一句话概括：** `MIN()` 函数找出指定列中的最小值。
*   **例子：找出公司中最低的薪水是多少**
    ```sql
    SELECT MIN(`salary`) AS `lowest_salary` FROM `employee`;
    ```

> **注意：** 聚合函数通常与 `GROUP BY` 子句一起使用，以便对数据进行分组后分别计算聚合值 (例如，计算每个部门的平均薪水)。这部分视频后面可能会讲，如果没讲也是SQL中非常重要的概念。目前我们是针对整个表或 `WHERE` 筛选后的整个结果集进行聚合。

## 1.13 #13 万用字元 (Wildcards) (P14)

*   **一句话概括：** 万用字元（通配符）与 `LIKE` 操作符一起在 `WHERE` 子句中使用，用于在文本数据中进行模糊匹配，`%` 代表零个或多个任意字符，`_` 代表一个任意字符。
*   **详细解释：**
    *   当你想搜索的文本模式不是完全精确时，万用字元非常有用。
    *   它们通常与 `LIKE` 操作符连用。
    *   主要有两个万用字元：
        1.  `%` (百分号)：代表 **零个、一个或多个** 任意字符。
        2.  `_` (底线/下划线)：代表 **一个** 任意字符。

*   **准备客户表 (Client) 数据：**
    *   确保 `client` 表存在且有数据。为了演示，假设 `client` 表除了 `client_name`，还有 `phone` 字段。
    ```sql
    DROP TABLE IF EXISTS `client`; -- 先删除以避免与 P11 的 client 表冲突
    CREATE TABLE `client` (
        `client_id` INT PRIMARY KEY,
        `client_name` VARCHAR(40),
        `phone` VARCHAR(20) -- 添加 phone 字段用于演示
    );
    INSERT INTO `client` VALUES
    (400, '阿狗宠物店', '254-335-8888'),
    (401, '旺来超市', '333-123-3354'),
    (402, '露西花坊', '250-888-3549'),
    (403, '艾瑞克科技', '555-354-0000'),
    (404, '老王烧饼', '254-000-1111');
    SELECT * FROM `client`;
    ```

### 1.13.1 ## 使用 `%` (百分号)

*   **例子1：取得电话号码尾数是 '335' 的客户** (视频是335，我改下数据匹配)
    *   假设要找尾数是 `8888` 的
    ```sql
    SELECT * FROM `client`
    WHERE `phone` LIKE '%8888';
    ```
    *   `'%8888'` 表示：前面可以是任意字符 (或没有字符)，只要最后是 '8888' 就匹配。
*   **例子2：取得电话号码开头是 '254' 的客户**
    ```sql
    SELECT * FROM `client`
    WHERE `phone` LIKE '254%';
    ```
    *   `'254%'` 表示：以 '254' 开头，后面可以是任意字符 (或没有字符)。
*   **例子3：取得电话号码中间包含 '354' 的客户**
    ```sql
    SELECT * FROM `client`
    WHERE `phone` LIKE '%354%';
    ```
    *   `'%354%'` 表示：'354' 前后都可以是任意字符 (或没有字符)。
*   **例子4：取得姓 "艾" 的客户 (假设客户名格式是"姓+名")**
    *   (视频中用 `client_name` LIKE '艾%'，但我的数据 `client_name` 都是公司名，这里我用员工表演示姓氏)
    *   假设 `employee` 表中 `last_name` 存的是姓。要找姓 "黄" 的员工：
    ```sql
    SELECT * FROM `employee`
    WHERE `last_name` LIKE '黄%';
    ```

### 1.13.2 ## 使用 `_` (底线)

*   **例子：取得生日在12月的员工**
    *   生日格式是 `YYYY-MM-DD`。12月表示月份部分是 `12`。
    *   年份4位，横杠1位，月份2位，横杠1位，日期2位。
    *   月份 `MM` 前面有 `YYYY-` 共5个字符。
    ```sql
    SELECT * FROM `employee`
    WHERE `birth_day` LIKE '_____12%'; -- 5个底线代表前面5个任意字符 (YYYY-)
                                      -- 然后是 '12' 代表12月
                                      -- 然后是 '%' 代表日及之后可以是任意 (DD...)
    -- 或者更精确一点，如果日期也必须是两位：
    -- WHERE `birth_day` LIKE '_____12-__'; -- 后面两个底线代表两位日期
    ```
    *   **验证：** `employee` 表的小黑 (`emp_id`=208) 生日是 '1990-11-23'。如果改成 '1990-12-23' 就能匹配。
        ```sql
        UPDATE `employee` SET `birth_day` = '1990-12-23' WHERE `emp_id` = 208;
        SELECT * FROM `employee` WHERE `birth_day` LIKE '_____12%';
        ```
*   **例子：取得生日在9月份的员工 (月份是 '09')**
    ```sql
    SELECT * FROM `employee`
    WHERE `birth_day` LIKE '_____09%';
    ```
    *   小绿 (`emp_id`=207) 生日是 '1985-05-09'。如果改成 '1985-09-09' 就能匹配。
        ```sql
        UPDATE `employee` SET `birth_day` = '1985-09-09' WHERE `emp_id` = 207;
        SELECT * FROM `employee` WHERE `birth_day` LIKE '_____09%';
        ```

> **注意：**
> *   `LIKE` 通常比 `=` 慢，因为它要做模式匹配。如果能用 `=` 精确匹配，尽量用 `=`。
> *   如果 `%` 或 `_` 本身就是你要搜索的字符 (例如，产品名包含 `_`)，你需要使用 **转义字符 (ESCAPE character)**。例如 `WHERE column LIKE '%\_%' ESCAPE '\';` 表示搜索真实的下划线。

## 1.14 #14 `UNION` - 合并查询结果 (P15)

*   **一句话概括：** `UNION` 操作符用于合并两个或多个 `SELECT` 语句的查询结果集，它会自动去除重复的行；如果想保留所有行（包括重复的），则使用 `UNION ALL`。
*   **详细解释：**
    *   `UNION` 可以把来自不同查询的行堆叠在一起，形成一个更大的结果集。
*   **使用 `UNION` 的规则：**
    1.  **列数必须相同：** 所有参与 `UNION` 的 `SELECT` 语句必须拥有相同数量的列。
    2.  **数据类型必须兼容：** 对应位置的列，其数据类型必须相似或可以隐式转换 (例如，`INT` 和 `DECIMAL` 可以，但 `INT` 和 `DATE` 通常不行)。
    3.  **列名以第一个 `SELECT` 为准：** 合并后结果集的列名，默认使用第一个 `SELECT` 语句中的列名。

### 1.14.1 ## 基本用法

*   **例子1：合并员工的名字 (`first_name`) 和客户的名字 (`client_name`)**
    ```sql
    SELECT `first_name` FROM `employee` -- 第一个查询，列名为 first_name
    UNION
    SELECT `client_name` FROM `client`;  -- 第二个查询
    ```
    *   结果会是一列，包含所有员工的 `first_name` 和所有客户的 `client_name`。
    *   如果某个名字在员工和客户中都出现，`UNION` 默认只显示一次 (去重)。
*   **例子2：合并员工名、客户名和部门名**
    ```sql
    SELECT `first_name` FROM `employee`
    UNION
    SELECT `client_name` FROM `client`
    UNION
    SELECT `branch_name` FROM `branch`;
    ```

### 1.14.2 ## `UNION ALL` - 保留重复行

*   **一句话概括：** `UNION ALL` 与 `UNION` 类似，但它不会去除重复的行，而是将所有查询结果原样合并。
*   **例子：**
    ```sql
    SELECT `branch_id` FROM `employee` -- 假设员工表有很多重复的 branch_id
    UNION ALL
    SELECT `branch_id` FROM `client`;   -- 客户表也有 branch_id
    ```
    *   这个结果会包含所有员工的 `branch_id` 和所有客户的 `branch_id`，即使有重复也会全部列出。
    *   `UNION ALL` 通常比 `UNION` 快，因为它省去了去重的步骤。

### 1.14.3 ## 合并多个列，并自定义列名

*   **例子：合并员工的 `emp_id` 和 `first_name`，以及客户的 `client_id` 和 `client_name`**
    ```sql
    SELECT `emp_id`, `first_name` FROM `employee`
    UNION
    SELECT `client_id`, `client_name` FROM `client`;
    ```
    *   结果会有两列，第一列是ID，第二列是名字。
    *   **列名问题：** 结果的列名会是 `emp_id` 和 `first_name` (来自第一个 `SELECT`)。
    *   **使用别名 (Alias) 统一列名：**
        ```sql
        SELECT `emp_id` AS `ID`, `first_name` AS `Name` FROM `employee`
        UNION
        SELECT `client_id` AS `ID`, `client_name` AS `Name` FROM `client`;
        ```
        *   这样结果列的名称就是 `ID` 和 `Name`，更清晰。
        *   其实只需要在第一个 `SELECT` 语句中指定别名，后续 `UNION` 的 `SELECT` 会自动匹配：
            ```sql
            SELECT `emp_id` AS `ID`, `first_name` AS `Name` FROM `employee`
            UNION
            SELECT `client_id`, `client_name` FROM `client`; -- 结果列名仍是 ID, Name
            ```

### 1.14.4 ## 合并不同含义但类型兼容的数据

*   **例子：合并员工的薪水 (`salary`) 和销售记录中的销售金额 (`total_sales`)**
    ```sql
    SELECT `salary` AS `Amount` FROM `employee`
    UNION
    SELECT `total_sales` AS `Amount` FROM `works_with`;
    ```
    *   这样可以得到一个包含所有薪水和销售额的列表，都叫做 `Amount`。

> **何时使用 `UNION` vs `JOIN`？**
> *   `UNION` 是把多个查询的结果 **行堆叠起来** (纵向合并)，通常用于合并相似结构但来自不同表或不同条件的数据。
> *   `JOIN` 是把多个表的 **列连接起来** (横向合并)，基于某些关联条件，用于从多个关联表中获取更完整的信息。 (下一节内容)

## 1.15 #15 `JOIN` - 连接表格 (P16)

*   **一句话概括：** `JOIN` 子句用于根据某些相关的列（通常是主外键关系）将来自两个或多个表中的行组合起来，从而能够在一个查询中获取和展示跨表的信息。
*   **详细解释：**
    *   当需要的信息分散在多个表中时，就需要用 `JOIN` 把它们“拼接”起来。
    *   **准备工作：** (视频中新增了一个 `branch` 记录方便演示 `LEFT JOIN` / `RIGHT JOIN`)
        ```sql
        -- 假设新增一个部门 "摸鱼部"，ID为4，没有经理
        INSERT INTO `branch` (`branch_id`, `branch_name`, `mgr_id`, `mgr_start_date`)
        VALUES (4, '摸鱼部', NULL, NULL);
        SELECT * FROM `branch`;
        ```

### 1.15.1 ## `(INNER) JOIN` - 内连接

*   **一句话概括：** `INNER JOIN` (通常直接写 `JOIN` 即可，`INNER` 是默认的) 只返回两个表中联接字段能够匹配上的行。如果某行在一个表中没有匹配的行，则不会出现在结果中。
*   **场景：取得所有部门及其经理的名字**
    *   部门信息在 `branch` 表 (有 `mgr_id`)。
    *   经理的名字在 `employee` 表 (通过 `emp_id` 关联 `mgr_id`)。
*   **SQL指令：**
    ```sql
    SELECT
        e.`emp_id`,         -- 员工ID
        e.`first_name`,     -- 经理名
        e.`last_name`,      -- 经理姓
        b.`branch_name`     -- 部门名
    FROM `employee` AS e    -- 主表 employee，别名为 e
    JOIN `branch` AS b      -- 要连接的表 branch，别名为 b
      ON e.`emp_id` = b.`mgr_id`; -- 连接条件：员工的emp_id 等于 部门的mgr_id
    ```
    *   `FROM \`employee\` AS e JOIN \`branch\` AS b`: 表示要连接 `employee` 表 (别名 `e`) 和 `branch` 表 (别名 `b`)。
    *   `ON e.\`emp_id\` = b.\`mgr_id\``: 这是 **连接条件 (Join Condition)**。它指定了如何匹配两个表中的行。这里是当员工的 `emp_id` 与部门的 `mgr_id` 相等时，这两行就匹配上了。
    *   `e.\`emp_id\``, `b.\`branch_name\``: 当多个表中有相同列名时 (虽然这里没有)，或者为了清晰，建议在列名前加上表别名和点 `.`。
*   **结果分析：**
    *   只会显示那些 `mgr_id` 在 `employee` 表中能找到对应 `emp_id` 的部门。
    *   比如，如果 "摸鱼部" 的 `mgr_id` 是 `NULL`，或者是一个不存在的 `emp_id`，那么 "摸鱼部" 就不会出现在 `INNER JOIN` 的结果里。
    *   如果某个员工不是任何部门的经理，他也不会出现在这个结果里。

### 1.15.2 ## `LEFT JOIN` (或 `LEFT OUTER JOIN`) - 左连接

*   **一句话概括：** `LEFT JOIN` 会返回左表（`FROM` 子句中先声明的表）的所有行，以及右表中匹配上的行；如果右表中没有匹配行，则右表的列显示为 `NULL`。
*   **SQL指令 (沿用上例，但想显示所有员工，以及他们管理的部门名，如果他们是经理的话)：**
    ```sql
    SELECT
        e.`emp_id`,
        e.`first_name`,
        e.`last_name`,
        b.`branch_name` -- 如果该员工不是经理，此列为 NULL
    FROM `employee` AS e    -- 左表
    LEFT JOIN `branch` AS b -- 右表
      ON e.`emp_id` = b.`mgr_id`;
    ```
*   **结果分析：**
    *   `employee` 表中的 **所有员工** 都会被列出。
    *   如果一个员工 (如小黄 `emp_id`=206) 是某个部门 (研发部) 的经理，那么 `branch_name` 会显示 "研发"。
    *   如果一个员工 (如小白 `emp_id`=209) **不是任何部门的经理**，他的 `branch_name` 会显示为 `NULL`。

### 1.15.3 ## `RIGHT JOIN` (或 `RIGHT OUTER JOIN`) - 右连接

*   **一句话概括：** `RIGHT JOIN` 与 `LEFT JOIN` 相反，它会返回右表（`JOIN` 关键字后声明的表）的所有行，以及左表中匹配上的行；如果左表中没有匹配行，则左表的列显示为 `NULL`。
*   **SQL指令 (显示所有部门，以及它们的经理名字，如果部门有经理的话)：**
    ```sql
    SELECT
        e.`first_name`, -- 如果该部门没有经理或经理ID无效，此列为 NULL
        e.`last_name`,  -- 同上
        b.`branch_name`
    FROM `employee` AS e    -- 左表
    RIGHT JOIN `branch` AS b -- 右表
      ON e.`emp_id` = b.`mgr_id`;
    ```
*   **结果分析：**
    *   `branch` 表中的 **所有部门** 都会被列出。
    *   如果一个部门 (如研发部) 有经理 (小黄 `emp_id`=206)，那么 `first_name`, `last_name` 会显示经理的名字。
    *   如果一个部门 (如新增的 "摸鱼部"，其 `mgr_id` 是 `NULL` 或无效值) **没有经理**，它的 `first_name`, `last_name` 会显示为 `NULL`。

> **`FULL OUTER JOIN` (MySQL不支持直接语法，但可模拟)：**
> *   会返回左表和右表中所有的行。如果某行在一个表中没有匹配，另一个表的列会显示 `NULL`。
> *   MySQL 没有直接的 `FULL OUTER JOIN` 语法，但可以用 `LEFT JOIN UNION RIGHT JOIN` 来模拟。
>     ```sql
>     SELECT e.first_name, e.last_name, b.branch_name
>     FROM employee AS e
>     LEFT JOIN branch AS b ON e.emp_id = b.mgr_id
>     UNION
>     SELECT e.first_name, e.last_name, b.branch_name
>     FROM employee AS e
>     RIGHT JOIN branch AS b ON e.emp_id = b.mgr_id
>     WHERE e.emp_id IS NULL; -- 避免重复LEFT JOIN已包含的部分，只取RIGHT JOIN独有的
>     ```

## 1.16 #16 子查询 (Subquery / Inner Query / Nested Query) (P17)

*   **一句话概括：** 子查询是嵌套在另一个SQL查询（主查询）内部的查询语句，它可以独立执行并返回一个结果，这个结果可以被主查询用来作为条件、数据源或其他用途。
*   **详细解释：**
    *   一个查询语句的结果可以作为另一个查询语句的输入或条件。
    *   子查询通常用括号 `()` 包起来。

### 1.16.1 ## 子查询用在 `WHERE` 子句中 (作为条件的一部分)

#### 1.16.1.1 #### 子查询返回单个值

*   **场景：找出研发部门的经理名字**
    1.  **步骤1 (子查询)：** 找出研发部门的 `mgr_id`。
        ```sql
        SELECT `mgr_id` FROM `branch` WHERE `branch_name` = '研发'; -- 假设返回 206
        ```
    2.  **步骤2 (主查询)：** 根据上一步得到的 `mgr_id` (206) 去 `employee` 表找对应的员工名字。
        ```sql
        SELECT `first_name`, `last_name` FROM `employee` WHERE `emp_id` = 206;
        ```
    *   **合并成带子查询的SQL：**
        ```sql
        SELECT e.`first_name`, e.`last_name`
        FROM `employee` AS e
        WHERE e.`emp_id` = ( -- 等号右边是子查询，它必须返回单个值
            SELECT b.`mgr_id`
            FROM `branch` AS b
            WHERE b.`branch_name` = '研发'
        );
        ```
        *   子查询 `(SELECT b.\`mgr_id\` FROM \`branch\` AS b WHERE b.\`branch_name\` = '研发')` 先执行，返回研发部门的经理ID (如 $206$)。
        *   然后主查询变成 `SELECT ... WHERE e.\`emp_id\` = 206;`

#### 1.16.1.2 #### 子查询返回多个值 (配合 `IN`, `ANY`, `ALL`)

*   **场景：找出对单一位客户销售金额超过 `$50000$` 的员工名字**
    1.  **步骤1 (子查询)：** 从 `works_with` 表找出 `total_sales` > `$50000$` 的所有 `emp_id`。
        ```sql
        SELECT `emp_id` FROM `works_with` WHERE `total_sales` > 50000;
        -- 这个查询可能返回多个 emp_id，例如 (206, 207)
        ```
    2.  **步骤2 (主查询)：** 根据上一步得到的 `emp_id` 列表去 `employee` 表找对应的员工名字。
    *   **合并成带子查询的SQL (使用 `IN`)：**
        ```sql
        SELECT e.`first_name`, e.`last_name`
        FROM `employee` AS e
        WHERE e.`emp_id` IN ( -- IN 操作符，因为子查询可能返回多行（多个emp_id）
            SELECT ww.`emp_id`
            FROM `works_with` AS ww
            WHERE ww.`total_sales` > 50000
        );
        ```
        *   子查询返回一个 `emp_id` 的列表。
        *   主查询 `WHERE e.\`emp_id\` IN (列表)` 表示只要员工的 `emp_id` 在这个列表里就满足条件。

### 1.16.2 ## 其他类型的子查询 (概念提及)

*   **子查询用在 `SELECT` 子句中 (标量子查询 Scalar Subquery)：**
    *   子查询返回单个值，作为主查询的一列。
    *   例子：查询每个员工及其所在部门的名称 (不使用JOIN，而是用子查询，效率较低)
        ```sql
        SELECT
            e.`first_name`,
            e.`last_name`,
            (SELECT b.`branch_name` FROM `branch` b WHERE b.`branch_id` = e.`branch_id`) AS `department_name`
        FROM `employee` e;
        ```
*   **子查询用在 `FROM` 子句中 (派生表 Derived Table)：**
    *   子查询的结果作为一个临时的表，供主查询使用。
    *   例子：查询平均薪水大于 `$60000$` 的部门信息 (假设先计算各部门平均薪水作为派生表)
        ```sql
        SELECT *
        FROM (
            SELECT `branch_id`, AVG(`salary`) AS avg_sal_per_branch
            FROM `employee`
            GROUP BY `branch_id`
        ) AS `branch_avg_salaries` -- 必须给派生表起别名
        WHERE `avg_sal_per_branch` > 60000;
        ```
    *   `GROUP BY` 是用于配合聚合函数对数据进行分组的，这里先不细讲，但子查询可以这样用。

> **子查询 vs JOIN：**
> *   很多时候，子查询可以被 `JOIN` 替代，反之亦然。
> *   `JOIN` 通常在性能上表现更好，因为数据库优化器对 `JOIN` 的处理更成熟。
> *   但有时子查询的逻辑更清晰易懂。
> *   选择哪种方式取决于具体场景、可读性和性能需求。

## 1.17 #17 `ON DELETE SET NULL` vs `ON DELETE CASCADE` (P18)

*   **一句话概括：** 这两者是定义外键约束时，指定当被引用的主键记录被删除时，引用表中外键应如何响应的规则：`ON DELETE SET NULL` 会将外键值设为 `NULL`，而 `ON DELETE CASCADE` 则会连锁删除包含该外键的整行记录。
*   **详细解释：**
    *   这是在 `CREATE TABLE` 或 `ALTER TABLE` 定义外键 (Foreign Key) 时可以设定的行为。
    *   它们决定了当父表 (被引用的表，即包含主键的表) 中的一条记录被删除时，子表 (引用表，即包含外键的表) 中相关的记录会发生什么。

### 1.17.1 ## `ON DELETE SET NULL`

*   **行为：** 当父表中被外键引用的那条记录被删除时，子表中所有引用了该记录的外键列的值会自动被设置为 `NULL`。
*   **前提：** 该外键列必须 **允许** 存储 `NULL` 值。如果外键列有 `NOT NULL` 约束，则不能使用 `ON DELETE SET NULL` (或者会导致删除父表记录失败)。
*   **回顾我们的表设计：**
    *   `branch.mgr_id` FK 指向 `employee.emp_id`，并设置了 `ON DELETE SET NULL`。
        ```sql
        -- CREATE TABLE `branch` ( ...
        -- FOREIGN KEY(`mgr_id`) REFERENCES `employee`(`emp_id`) ON DELETE SET NULL
        -- );
        ```
*   **例子：**
    1.  **当前状态：** 假设行政部门 (`branch_id`=2) 的经理是小绿 (`mgr_id`=207)。
        ```sql
        SELECT * FROM `branch` WHERE `branch_id` = 2; -- mgr_id 应该是 207
        SELECT * FROM `employee` WHERE `emp_id` = 207; -- 小绿的信息
        ```
    2.  **操作：删除员工小绿 (emp_id=207) 的记录。**
        ```sql
        DELETE FROM `employee` WHERE `emp_id` = 207;
        ```
    3.  **结果：**
        *   员工小绿的记录从 `employee` 表中消失了。
        *   查看 `branch` 表中行政部门的记录：
            ```sql
            SELECT * FROM `branch` WHERE `branch_id` = 2;
            ```
            你会发现行政部门的 `mgr_id` 变成了 `NULL`。因为小绿 (原经理) 被删了，部门不能再引用一个不存在的经理ID，所以根据 `ON DELETE SET NULL` 规则，`mgr_id` 被设为 `NULL`。

### 1.17.2 ## `ON DELETE CASCADE`

*   **行为：** 当父表中被外键引用的那条记录被删除时，子表中所有引用了该记录的 **整行数据** 也会被自动 **连锁删除**。
*   **这是一个比较强烈的约束，可能导致数据丢失，需谨慎使用。**
*   **回顾我们的表设计：**
    *   `works_with.emp_id` FK 指向 `employee.emp_id`，设置了 `ON DELETE CASCADE`。
    *   `works_with.client_id` FK 指向 `client.client_id`，也设置了 `ON DELETE CASCADE`。
        ```sql
        -- CREATE TABLE `works_with` ( ...
        -- FOREIGN KEY (`emp_id`) REFERENCES `employee`(`emp_id`) ON DELETE CASCADE,
        -- FOREIGN KEY (`client_id`) REFERENCES `client`(`client_id`) ON DELETE CASCADE
        -- );
        ```
*   **例子：** (接上例，小绿 `emp_id`=207 已经被删了)
    1.  **准备：** 先恢复小绿，并假设小绿之前有一些销售记录。
        ```sql
        -- 重新插入小绿 (假设其他信息)
        INSERT INTO `employee` VALUES(207, '绿', '小', '1985-05-09', 'F', 60000, 2, 206);
        -- 假设小绿有一条 works_with 记录
        -- 先确保客户402存在
        -- INSERT IGNORE INTO `client` VALUES(402, '王五集团', 2); -- IGNORE避免主键冲突
        -- INSERT INTO `works_with` VALUES(207, 402, 120000);
        -- 检查 works_with 中是否有 emp_id = 207 的记录
        SELECT * FROM `works_with` WHERE `emp_id` = 207;
        ```
        *   (根据 P11 的数据，emp_id 207 (小绿) 确实有一条 works_with 记录 `(207, 402, 120000)`)
    2.  **操作：再次删除员工小绿 (emp_id=207)。**
        ```sql
        DELETE FROM `employee` WHERE `emp_id` = 207;
        ```
    3.  **结果：**
        *   员工小绿的记录从 `employee` 表中消失。
        *   查看 `works_with` 表：
            ```sql
            SELECT * FROM `works_with` WHERE `emp_id` = 207;
            ```
            你会发现，之前 `emp_id` 是 $207$ 的那条销售记录也 **不见了**。因为它被连锁删除了 (CASCADE)。

### 1.17.3 ## 何时使用哪个？

*   **`ON DELETE SET NULL` 适用场景：**
    *   当父记录删除后，子记录的这条关联变得“可选”或“未知”时。
    *   例如：员工离职了 (被删除)，他之前管理的部门现在暂时没有经理了 (`mgr_id` 设为 `NULL`)，但部门本身还存在。
    *   子表的外键列必须允许 `NULL`。
*   **`ON DELETE CASCADE` 适用场景：**
    *   当子记录的存在完全依赖于父记录时，父记录没了，子记录也应该没了。
    *   例如：一个订单 (父) 和它的订单项 (子)。如果订单被删除了，它的所有订单项也应该一起被删除，因为订单项不能脱离订单单独存在。
    *   在我们的例子中，如果一个员工离职了，他之前的所有销售业绩 (`works_with` 记录) 也跟着删除是合理的，因为这些业绩是和他绑定的。
    *   **注意：** 如果外键列同时也是主键的一部分 (如 `works_with` 表中的 `emp_id` 和 `client_id`)，那么该列不能被设为 `NULL` (因为主键部分不能为 `NULL`)。这种情况下，通常只能用 `ON DELETE CASCADE` 或 `ON DELETE RESTRICT` (或 `NO ACTION`，都是不允许删除父记录如果子表有引用)。视频中提到，如果FK同时是PK，不能用 `ON DELETE SET NULL`，这是正确的。

*   **其他选项 (不常用或默认行为)：**
    *   `ON DELETE RESTRICT`: 如果子表中有记录引用父表记录，则不允许删除父表记录 (会报错)。这是很多数据库的默认行为，如果你不指定 `ON DELETE ...`。
    *   `ON DELETE NO ACTION`: 类似 `RESTRICT`，在MySQL中基本等同。

## 1.18 #18 用Python连接MySQL (P19)

*   **一句话概括：** 可以使用 Python 的第三方库（如 `mysql-connector-python`）来连接到 MySQL 数据库服务器，执行 SQL 查询，并获取或修改数据，从而实现通过编程方式与数据库交互。
*   **详细解释：**
    *   这里演示如何用 Python 程序连接到我们之前安装和操作的 MySQL 数据库。
    *   其他编程语言 (Java, Node.js, PHP, C#等) 也有类似的连接库和方法。

### 1.18.1 ## 1. 安装连接库

*   **库名：** `mysql-connector-python`
*   **安装命令 (在终端或命令行中执行)：**
    ```bash
    pip install mysql-connector-python
    ```
    *   `pip` 是 Python 的包安装器。如果提示 `pip` 命令找不到，可能需要先安装Python或配置环境变量。
    *   如果已安装，它会提示已满足要求。

### 1.18.2 ## 2. Python 连接代码基本结构

```python
import mysql.connector # 引入安装好的库

try:
    # 建立连接
    mydb = mysql.connector.connect(
        host="localhost",    # MySQL 服务器地址 (本机通常是 localhost 或 127.0.0.1)
        port="3306",         # MySQL 服务器端口 (默认是 3306)
        user="root",         # MySQL 用户名 (我们安装时设置的是 root)
        password="your_password" # 你为 root 用户设置的密码
        # database="sql_tutorial" # 可选：直接指定要操作的数据库
    )

    if mydb.is_connected():
        print("成功连接到MySQL数据库！")

    # 创建一个cursor对象 (游标)，用于执行SQL语句
    mycursor = mydb.cursor()

    # --- 在这里执行SQL操作 ---
    # mycursor.execute("SQL 命令")
    # example: mycursor.execute("SHOW DATABASES;")
    # for db in mycursor:
    #    print(db)

    # 关闭游标
    mycursor.close()

except mysql.connector.Error as err:
    print(f"连接MySQL失败: {err}")

finally:
    # 关闭数据库连接
    if 'mydb' in locals() and mydb.is_connected():
        mydb.close()
        print("MySQL连接已关闭。")
```
*   **`host`**: MySQL服务器运行的主机名或IP地址。如果是本机，就是 `localhost` 或 `$127.0.0.1$`。
*   **`port`**: MySQL服务器监听的端口号，默认是 `$3306$`。
*   **`user`**: 连接数据库用的用户名，我们安装时用的是 `root`。
*   **`password`**: 上述用户的密码。**非常重要：在实际项目中，不要把密码硬编码在代码里，应该用更安全的方式管理，比如环境变量、配置文件等。**
*   **`database` (可选参数)**: 如果在 `connect()` 时指定了数据库名，那么后续操作就默认针对这个数据库，不需要再执行 `USE database_name;`。
*   **`mydb.cursor()`**: 创建一个游标对象。我们通过游标来执行SQL语句和获取结果。
*   **`mycursor.execute("SQL语句")`**: 执行SQL语句。
*   **获取查询结果 (对于 `SELECT` 语句)：**
    *   `mycursor.fetchone()`: 获取结果集中的下一行 (一个元组)。
    *   `mycursor.fetchall()`: 获取结果集中的所有行 (一个包含元组的列表)。
    *   可以直接遍历 `mycursor` 对象获取所有行。
*   **`mydb.commit()`**: 对于会修改数据的操作 (如 `INSERT`, `UPDATE`, `DELETE`)，执行 `execute()` 后，还需要调用 `mydb.commit()` 来提交事务，使更改永久生效。如果发生错误，可以用 `mydb.rollback()` 回滚。
*   **`mycursor.close()`**: 关闭游标。
*   **`mydb.close()`**: 关闭数据库连接。**始终确保连接在使用完毕后被关闭**，以释放资源。`try...finally` 结构可以保证即使发生错误，连接也会被关闭。

### 1.18.3 ## 3. 示例操作

#### 1.18.3.1 #### 示例1：创建数据库 `qq` 并显示所有数据库

```python
import mysql.connector

try:
    mydb = mysql.connector.connect(
        host="localhost",
        user="root",
        password="your_password" # 替换成你的密码
    )
    mycursor = mydb.cursor()

    # 创建数据库 (如果不存在)
    mycursor.execute("CREATE DATABASE IF NOT EXISTS qq")
    print("数据库 qq 已创建或已存在。")

    # 显示所有数据库
    mycursor.execute("SHOW DATABASES")
    print("\n当前数据库列表:")
    for db_name_tuple in mycursor: # mycursor 是一个迭代器
        print(db_name_tuple[0])    # 每个元素是元组，如 ('sql_tutorial',)

    mycursor.close()
except mysql.connector.Error as err:
    print(f"操作失败: {err}")
finally:
    if 'mydb' in locals() and mydb.is_connected():
        mydb.close()
```

#### 1.18.3.2 #### 示例2：在 `sql_tutorial` 数据库中创建表 `test_table`

```python
import mysql.connector

try:
    mydb = mysql.connector.connect(
        host="localhost",
        user="root",
        password="your_password", # 替换成你的密码
        database="sql_tutorial"   #直接连接到 sql_tutorial 数据库
    )
    mycursor = mydb.cursor()

    # 使用 sql_tutorial 数据库 (如果在connect时没有指定database，则需要这句)
    # mycursor.execute("USE sql_tutorial")

    # 创建表
    mycursor.execute("""
        CREATE TABLE IF NOT EXISTS `py_test_table` (
            `id` INT AUTO_INCREMENT PRIMARY KEY,
            `name` VARCHAR(50)
        )
    """)
    print("表 py_test_table 在 sql_tutorial 中已创建或已存在。")

    mycursor.close()
except mysql.connector.Error as err:
    print(f"操作失败: {err}")
finally:
    if 'mydb' in locals() and mydb.is_connected():
        mydb.close()
```

#### 1.18.3.3 #### 示例3：从 `sql_tutorial` 的 `branch` 表获取数据

```python
import mysql.connector

try:
    mydb = mysql.connector.connect(
        host="localhost",
        user="root",
        password="your_password", # 替换成你的密码
        database="sql_tutorial"
    )
    mycursor = mydb.cursor()

    mycursor.execute("SELECT * FROM `branch`")
    
    results = mycursor.fetchall() # 获取所有结果行

    print("\nBranch 表数据:")
    for row in results:
        print(row) # 每一行是一个元组 (branch_id, branch_name, mgr_id, mgr_start_date)

    mycursor.close()
except mysql.connector.Error as err:
    print(f"操作失败: {err}")
finally:
    if 'mydb' in locals() and mydb.is_connected():
        mydb.close()
```

#### 1.18.3.4 #### 示例4：新增、修改、删除资料 (需要 `mydb.commit()`)

```python
import mysql.connector

try:
    mydb = mysql.connector.connect(
        host="localhost",
        user="root",
        password="your_password", # 替换成你的密码
        database="sql_tutorial"
    )
    mycursor = mydb.cursor()

    # 1. 新增资料到 branch 表
    sql_insert = "INSERT INTO `branch` (`branch_id`, `branch_name`, `mgr_id`) VALUES (%s, %s, %s)"
    # 视频中 branch_id 是5，部门名是 'QQ'，mgr_id 是 NULL
    val_insert = (5, 'QQ部门', None) # 使用参数化查询防止SQL注入，%s是占位符
    mycursor.execute(sql_insert, val_insert)
    mydb.commit() # 提交更改
    print(f"{mycursor.rowcount} 条记录已插入到 branch。") # mycursor.rowcount 显示受影响的行数

    # 2. 修改资料 (branch_id=4 的部门，将其 mgr_id 修改为 206)
    # (假设 branch_id=4 是 '摸鱼部')
    sql_update = "UPDATE `branch` SET `mgr_id` = %s WHERE `branch_id` = %s"
    val_update = (206, 4)
    mycursor.execute(sql_update, val_update)
    mydb.commit()
    print(f"{mycursor.rowcount} 条记录已更新。")

    # 3. 删除资料 (删除 branch_id=5 的部门，即刚才插入的 'QQ部门')
    sql_delete = "DELETE FROM `branch` WHERE `branch_id` = %s"
    val_delete = (5,) # 注意：单个值的元组也要有逗号
    mycursor.execute(sql_delete, val_delete)
    mydb.commit()
    print(f"{mycursor.rowcount} 条记录已删除。")

    mycursor.close()
except mysql.connector.Error as err:
    print(f"操作失败: {err}")
    if 'mydb' in locals() and mydb.is_connected():
        mydb.rollback() # 如果发生错误，回滚更改
        print("更改已回滚。")
finally:
    if 'mydb' in locals() and mydb.is_connected():
        mydb.close()
```
*   **参数化查询：** 注意在 `INSERT`, `UPDATE`, `DELETE` 中，使用 `%s` 作为占位符，并将实际值作为元组传递给 `execute()` 的第二个参数。这是一种更安全的做法，可以防止 **SQL注入** 攻击。

---

这个笔记应该覆盖了视频中的所有核心内容，并且尽可能地解释了每个细节和来源。希望对你的学习有帮助！
```