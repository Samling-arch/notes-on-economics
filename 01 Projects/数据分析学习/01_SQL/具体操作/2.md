好的，同学！这节课我们来聊聊MySQL里的“数据积木块”——数据类型。这非常重要，就像学任何语言都要先认识它的字母和词汇一样！

# 1 MySQL从基础到进阶 - 第四节：数据表操作与数据类型

## 1.1 零、回顾与引言：从数据库到数据表

**一句话概括：** 数据库像个大文件夹，数据表就是里面的Excel文件；我们现在要学习的，不是怎么直接操作这些“Excel文件”，而是先搞清楚这些“Excel文件”的“单元格”里能放什么样的数据。

*   上一课我们学习了数据库（Database）的增删改查。数据库，你可以把它想象成电脑里的一个**文件夹**。
*   我们用 `USE 数据库名;` 命令，就相当于**进入了这个文件夹**。
*   现在文件夹（数据库空间）有了，接下来就要在里面创建和管理**数据表（Table）**了。数据表就像这个文件夹里的一个个**Excel文件**。
*   在我们往表里填写一行行的数据（记录）之前，必须先定义好这个“Excel文件”的结构。

## 1.2 一、为什么需要数据类型？Excel的“任性”与数据库的“严谨”

**一句话概括：** 数据库比Excel更严格，它要求你给每一列（字段）指定一种数据类型，就像规定“学号”这一列只能放数字，“姓名”这一列只能放文字一样，这样能保证数据的准确和规范。

*   想象一下Excel，你可以在“学号”那一列填数字 `1001`，也可以填文字 `“张三”`，甚至填 `“apple”`，Excel不会拦你。
    *   ![Excel示意图](https://i.imgur.com/KqDRxJI.png)
    *   在上图中，如果这是Excel，你在“学号”列输入“壹仟零壹”或者“apple”，Excel是不会报错的。
*   但在数据库里，这是**不允许的**！
*   创建数据表时，除了表名（比如 `students` 表），还需要定义表的“列”，我们称之为 **字段（Field）**。
    *   比如上图中的“学号”、“姓名”、“性别”、“年龄”都是字段。
*   仅仅有字段名还不够，数据库比Excel多了一个关键东西：**数据类型（Data Type）** 和 **约束（Constraint）**。
    *   **数据类型**：规定了这个字段（这一列）只能存放什么类型的数据。比如，“学号”规定是数字，你就不能存入文字。
    *   **约束**：对字段值的额外限制。
        *   比如，`唯一约束 (UNIQUE)`：学号不能重复，你输入了 `1001`，再输入一个 `1001` 就会报错。
        *   比如，`非空约束 (NOT NULL)`：姓名不能为空，你必须填写。
        *   (约束我们会在后续课程详细讲，这节课重点是数据类型)。
*   **核心：** 类型是必须的，约束可以不加，但类型一定要有！
    *   如果“年龄”字段规定是整数，你就不能存入 `18.8` (带小数的)。
    *   如果“生日”字段，你存成字符串 `“1990-03-16”`，虽然看起来没问题，但如果你想查询“2000年以前出生的学生”，用字符串去比较年份会非常麻烦和低效。所以，数据库提供了专门的日期类型。

## 1.3 二、MySQL支持的数据类型详解

**一句话概括：** MySQL提供了多种数据类型，就像提供了不同形状和材质的积木块，让我们能准确地存储和操作各种数据，如文字、数字、日期等。

### 1.3.1 字符串类型 (String Types)

**一句话概括：** 字符串类型用来存储文本信息，比如姓名、地址、文章内容等；最常用的是`VARCHAR`，因为它可以存储可变长度的文本，更节省空间。

*   字符串是编程和数据库中最常见的数据之一。

*   #### `CHAR(M)` - 定长字符串
    *   **通俗解释：** 就像一个固定长度的盒子，比如`CHAR(3)`，这个盒子就只能放正好3个字符的东西。
    *   **来源/细节：**
        *   `M` 代表字符长度，范围是 $0$ 到 $255$。
        *   如果你定义了 `name CHAR(10)`，那么不管你存入 "Tom" (3个字符) 还是 "Alexander" (9个字符)，它在数据库中都会占用10个字符的空间。如果存入的字符少于 `M`，通常会用空格在右侧补齐 (具体行为可能受SQL模式影响)。如果多于 `M`，会报错或被截断。
    *   **例子：**
        ```sql
        -- 假设有一个字段叫 short_code CHAR(3)
        -- 存入 'AB' (2字符), 实际存储可能是 'AB ' (补一个空格)
        -- 存入 'ABC' (3字符), 实际存储是 'ABC'
        -- 存入 'ABCD' (4字符), 可能会报错或截断成 'ABC'
        ```
    *   **使用场景：** 存储长度非常固定的数据，比如性别（'男'/'女'，虽然现在更推荐用`ENUM`或`TINYINT`），邮政编码（如果长度固定）。但因为不够灵活，**用得比较少**。

*   #### `VARCHAR(M)` - 变长字符串 (⭐最常用)
    *   **通俗解释：** 就像一个可伸缩的袋子，比如`VARCHAR(25)`，这个袋子最多能装25个字符的东西，但你实际装多少，它就占多大空间（外加一点点记录长度的空间）。
    *   **来源/细节：**
        *   `M` 代表最大字符长度。在MySQL 5.0.3版本之前，`M` 的范围是 $0$ 到 $255$；之后的版本 `M` 最大可以到 $65535$ (理论值，实际受字符集和行大小限制)。
        *   它只使用实际需要的空间，外加1或2个字节来存储字符串的实际长度。
        *   **`VAR` 的意思是 Variable (可变的)。**
    *   **例子：**
        ```sql
        -- 假设有一个字段叫 student_name VARCHAR(50)
        -- 存入 'Yuan' (4字符), 实际占用 4字符 + 1字节(长度) 的空间
        -- 存入 'Eric' (4字符), 实际占用 4字符 + 1字节(长度) 的空间
        -- 存入一个很长的名字 (比如40字符), 占用 40字符 + 1或2字节(长度) 的空间
        -- 只要不超过50个字符都没问题。
        ```
    *   **使用场景：** 绝大多数文本数据，如姓名、标题、地址等。**99%以上情况用这个！**

*   #### `TEXT` 类型家族 - 长文本字符串
    *   **通俗解释：** 当你需要存储一篇文章、很长的备注或者商品详情时，`VARCHAR` 可能不够长，这时就需要`TEXT`类型的“大袋子”了。
    *   **来源/细节：** 用于存储大量的文本数据。它们之间主要是最大长度不同：
        *   `TINYTEXT`: 最大长度 $255$ ($2^8 - 1$) 个字符。
        *   `TEXT`: 最大长度 $65,535$ ($2^{16} - 1$) 个字符 (约64KB)。
        *   `MEDIUMTEXT`: 最大长度 $16,777,215$ ($2^{24} - 1$) 个字符 (约16MB)。
        *   `LONGTEXT`: 最大长度 $4,294,967,295$ ($2^{32} - 1$) 个字符 (约4GB)。
    *   **例子：**
        ```sql
        -- 假设有一个字段叫 article_content TEXT
        -- 存入一篇几千字的文章。
        -- 假设有一个字段叫 product_description MEDIUMTEXT
        -- 存入非常详细的商品图文描述（虽然图片通常存路径）。
        ```
    *   **使用场景：** 存储文章内容、用户评论、较长的描述信息等。当字符串长度可能超过几百上千时，考虑使用它们。**用的频率相对较低，但特定场景很有用。**

*   #### `ENUM('值1', '值2', ...)` - 枚举类型
    *   **通俗解释：** 让你从预设的几个选项中“单选”一个值。比如性别字段，你规定只能是 '男'、'女'、'保密' 中的一个。
    *   **来源/细节：**
        *   `ENUM` 是 "enumeration" (枚举) 的缩写。
        *   列表中的值在内部存储为数字索引 ($1, 2, 3, ...$)，但表现为字符串。
        *   最多可以有 $65535$ 个不同的枚举值。
        *   如果插入的值不在枚举列表中（且SQL模式不严格），它可能会插入一个空字符串 `''` (如果允许NULL，则为NULL，或者第一个枚举成员，如果该列定义为`NOT NULL`）。
        *   **只能选择列表中的一个值。**
    *   **例子：**
        ```sql
        -- 假设有一个字段叫 gender ENUM('男', '女', '保密')
        -- 插入时:
        -- INSERT INTO ... (gender) VALUES ('男'); -- 正确
        -- INSERT INTO ... (gender) VALUES ('未知'); -- 错误 (如果严格模式) 或插入空/默认值
        ```
    *   **使用场景：** 字段的值是固定且有限的几个选项，如性别、订单状态 ('待付款', '已付款', '已发货', '已完成')。

*   #### `SET('值1', '值2', ...)` - 集合类型
    *   **通俗解释：** 让你从预设的几个选项中“多选”零个或多个值。比如爱好字段，一个人可以同时有 '唱歌' 和 '跳舞' 两个爱好。
    *   **来源/细节：**
        *   可以从列表中选择 $0$ 个、 $1$ 个或多个值。
        *   最多可以有 $64$ 个不同的成员。
        *   内部存储为位图（bitmap）。
    *   **例子：**
        ```sql
        -- 假设有一个字段叫 hobbies SET('唱歌', '跳舞', '阅读', '编程')
        -- 插入时:
        -- INSERT INTO ... (hobbies) VALUES ('唱歌'); -- 正确
        -- INSERT INTO ... (hobbies) VALUES ('跳舞,编程'); -- 正确，多个值用逗号分隔
        -- INSERT INTO ... (hobbies) VALUES (''); -- 正确，表示没有选择任何爱好
        ```
    *   **使用场景：** 用户的标签、文章的分类（如果一篇可以属于多个分类）等。**用得比较少。**

### 1.3.2 整数类型 (Integer Types)

**一句话概括：** 整数类型用来存储不带小数的数字，比如年龄、数量、ID号；根据数字可能的大小范围选择不同的`INT`变种，可以更有效地利用存储空间。

*   整数类型用于存储各种大小的整数。`INT` 是 "Integer" (整数) 的缩写。

*   #### `TINYINT` - 微小整数
    *   **通俗解释：** 最小的整数盒子，占1个字节。
    *   **来源/细节：**
        *   占用 $1$ 个字节 (Byte) 的存储空间。 $1$ 字节 = $8$ 比特 (bit)。
        *   **有符号 (SIGNED，默认):** 范围是 $-128$ 到 $127$。 ($ -2^{8-1} $ 到 $ 2^{8-1}-1 $)
        *   **无符号 (UNSIGNED):** 范围是 $0$ 到 $255$。 ($ 0 $ 到 $ 2^8-1 $)
        *   如何计算范围：一个字节有8位。如果是无符号，那么它可以表示 $2^8 = 256$ 个不同的数 (从0到255)。如果是有符号，最高位表示符号，所以数值范围减半，正负均分。
    *   **例子：**
        ```sql
        -- 假设 age TINYINT UNSIGNED
        -- 可以存 0, 18, 100, 255
        -- 不能存 256 或 -1
        -- 假设 status TINYINT SIGNED
        -- 可以存 -1, 0, 1, 127
        ```
    *   **使用场景：** 年龄（如果用`UNSIGNED`，最大能到255岁，一般够了）、状态值（比如0, 1, 2表示不同状态）。

*   #### `SMALLINT` - 小整数
    *   **通俗解释：** 比`TINYINT`大一点的整数盒子，占2个字节。
    *   **来源/细节：**
        *   占用 $2$ 个字节 ($16$ 比特)。
        *   **有符号:** $-32,768$ 到 $32,767$。 ($ -2^{16-1} $ 到 $ 2^{16-1}-1 $)
        *   **无符号:** $0$ 到 $65,535$。 ($ 0 $ 到 $ 2^{16}-1 $)
    *   **使用场景：** 存储一些小范围的计数，比如一个班级的人数。

*   #### `MEDIUMINT` - 中等整数
    *   **通俗解释：** 中等大小的整数盒子，占3个字节。
    *   **来源/细节：**
        *   占用 $3$ 个字节 ($24$ 比特)。
        *   **有符号:** $-8,388,608$ 到 $8,388,607$。 ($ -2^{24-1} $ 到 $ 2^{24-1}-1 $)
        *   **无符号:** $0$ 到 $16,777,215$。 ($ 0 $ 到 $ 2^{24}-1 $)
    *   **使用场景：** 用的不多，但如果数值范围正好合适，可以选用。

*   #### `INT` (或 `INTEGER`) - 标准整数 (⭐常用)
    *   **通俗解释：** 最常用的标准整数盒子，占4个字节。
    *   **来源/细节：**
        *   占用 $4$ 个字节 ($32$ 比特)。
        *   **有符号:** $-2,147,483,648$ 到 $2,147,483,647$ (约正负21亿)。 ($ -2^{32-1} $ 到 $ 2^{32-1}-1 $)
        *   **无符号:** $0$ 到 $4,294,967,295$ (约42亿)。 ($ 0 $ 到 $ 2^{32}-1 $)
    *   **例子：**
        ```sql
        -- 假设 user_id INT UNSIGNED
        -- 可以作为用户ID，支持超过40亿用户
        ```
    *   **使用场景：** 大部分ID主键、计数器等。老师说他要用`INT`存年龄，因为他长寿（这是个玩笑话，`TINYINT UNSIGNED`足够存年龄了）。

*   #### `BIGINT` - 大整数
    *   **通俗解释：** 超大的整数盒子，占8个字节，用来存非常非常大的数。
    *   **来源/细节：**
        *   占用 $8$ 个字节 ($64$ 比特)。
        *   **有符号:** 约 $-9 \times 10^{18}$ 到 $9 \times 10^{18}$。 ($ -2^{64-1} $ 到 $ 2^{64-1}-1 $)
        *   **无符号:** 约 $0$ 到 $1.8 \times 10^{19}$。 ($ 0 $ 到 $ 2^{64}-1 $)
    *   **使用场景：** 当`INT`的范围不够用时，比如分布式系统中的全局唯一ID、天文数字等。

*   **关于有符号 (SIGNED) 和无符号 (UNSIGNED)：**
    *   **有符号**：可以存储正数、负数和零。
    *   **无符号**：只能存储正数和零。如果你确定某个字段（如年龄、ID）永远不会是负数，使用`UNSIGNED`可以使其正数范围扩大一倍。

### 1.3.3 布尔类型 (Boolean Type)

**一句话概括：** MySQL本身没有专门的“真”(True)或“假”(False)值，我们通常用一个非常小的整数（比如`TINYINT(1)`，约定0代表假，1代表真）或者一个特定字符来模拟布尔值。

*   严格来说，MySQL **没有内置的 `BOOLEAN` 或 `BOOL` 类型**。
*   虽然你可以用 `BOOLEAN` 或 `BOOL` 来声明一个字段，但MySQL会自动将其转换为 `TINYINT(1)`。
*   **约定俗成的规范：**
    *   用数字 `0` 代表 `FALSE` (假)。
    *   用数字 `1` 代表 `TRUE` (真)。 (实际上，非0的数字通常都被认为是TRUE)。
*   **老师提到的其他模拟方式：**
    *   `VARCHAR(1)`: 存入字符 `'0'` 代表 `FALSE`，字符 `'1'` 代表 `TRUE`。 (老师觉得这样可读性更好，但一般不这么用)
    *   `BIT(1)`: (后面二进制类型会讲) 只能存 $0$ 或 $1$。这是更精确的模拟。
*   **例子：**
    ```sql
    -- 声明一个字段 is_active BOOLEAN
    -- MySQL 内部会处理成 is_active TINYINT(1)
    -- 插入时:
    -- INSERT INTO ... (is_active) VALUES (1); -- 代表 True (激活)
    -- INSERT INTO ... (is_active) VALUES (0); -- 代表 False (未激活)
    ```
*   **原因：** MySQL没有原生的`TRUE`和`FALSE`关键字来直接存储布尔状态，所以我们通过这种数字约定来间接实现。

### 1.3.4 浮点数类型 (Floating-Point Types) / 小数类型

**一句话概括：** 浮点数类型用来存储带有小数的数字，比如商品价格、平均分；对于精度要求非常高（尤其金钱相关）的场景，推荐使用`DECIMAL`。

*   用于存储包含小数部分的数字。

*   #### `FLOAT(M, D)` - 单精度浮点数
    *   **通俗解释：** 一种存小数的类型，但它存的是近似值，可能会有微小的误差，就像尺子刻度不够细。
    *   **来源/细节：**
        *   占用 $4$ 个字节。
        *   `M` 是总共的数字位数（精度）。
        *   `D` 是小数点后的位数（标度）。
        *   例如 `FLOAT(7,2)` 表示总共最多7位数，其中2位是小数，如 $12345.67$。
        *   **注意：** `FLOAT` 是一个近似值数字类型，进行计算时可能会有精度损失。
    *   **使用场景：** 对精度要求不高的科学计算。**不推荐用于存储货币等需要精确值的场合。**

*   #### `DOUBLE(M, D)` (或 `REAL`) - 双精度浮点数
    *   **通俗解释：** 比`FLOAT`更精确一点的小数类型（刻度更细的尺子），但仍然是近似值。
    *   **来源/细节：**
        *   占用 $8$ 个字节。
        *   `M` 和 `D` 的含义同 `FLOAT`。
        *   精度比 `FLOAT` 高，但也是近似值。
    *   **例子 (FLOAT/DOUBLE 共用)：**
        ```sql
        -- 假设 price DOUBLE(5, 2)
        -- 可以存 999.99
        -- 如果存 12.345，实际可能存为 12.35 (四舍五入) 或 12.34 (截断)，取决于D的设置
        -- 如果要存 1000.00，会报错，因为总位数M是5，而1000.00是6位(1000.)加上2位小数(00)，实际上是整数部分3位，小数部分2位，总共5位。1000.00的整数部分就有4位了。
        -- 老师的例子： DOUBLE(5,2) 表示总共5位，小数点后2位。例如：
        -- 123.45 (1,2,3,4,5 一共5位)
        -- 最大是 999.99
        -- 如果要存 1000.00，就需要 DOUBLE(6,2) 这样总位数是6位，小数点后2位。
        -- 最大是 9999.99
        ```
    *   **使用场景：** 科学计算，当`FLOAT`精度不足时。**同样不推荐用于货币。**

*   #### `DECIMAL(M, D)` (或 `NUMERIC`) - 定点数 (⭐推荐用于精确值)
    *   **通俗解释：** 这是专门用来精确存储小数的类型，就像银行账户里的钱，一分都不能差。
    *   **来源/细节：**
        *   以字符串形式存储精确的数值。
        *   `M` 是总位数（精度），最大为 $65$。
        *   `D` 是小数点后的位数（标度），最大为 $30$。`D` 必须小于等于 `M`。
        *   非常适合存储货币、汇率等需要高精度的值。
    *   **例子：**
        ```sql
        -- 假设 salary DECIMAL(10, 2)
        -- 可以精确存储如 12345678.90 这样的薪资数据
        ```
    *   **使用场景：** **强烈推荐用于存储货币金额、财务数据等任何要求精确计算的场景。**

*   **`M` 和 `D` 的重要性 (适用于 FLOAT, DOUBLE, DECIMAL):**
    *   `M` (Precision): 数字的总位数（整数部分 + 小数部分）。
    *   `D` (Scale): 小数点后的位数。
    *   例如，`DECIMAL(5,2)` 表示这个数总共最多有5位数字，其中小数点后有2位。所以它可以存储从 $-999.99$ 到 $999.99$ 的数。
    *   如果你尝试插入一个超出这个范围的数，比如 `1000.00` (整数部分就有4位了，总共需要6位才能表示 `1000.00`)，就会报错。

### 1.3.5 日期和时间类型 (Date and Time Types)

**一句话概括：** 日期时间类型专门用来存储和操作日期、时间信息，比如生日、文章发布时间；最常用的是`DATETIME`，因为它可以精确到年月日时分秒。

*   用于存储与日期和时间相关的值。

*   #### `DATE` - 日期
    *   **通俗解释：** 只存储年月日。
    *   **来源/细节：**
        *   格式：`'YYYY-MM-DD'` (年-月-日)。
        *   范围：`'1000-01-01'` 到 `'9999-12-31'`。
        *   占用 $3$ 个字节。
    *   **例子：**
        ```sql
        -- 假设 birthday DATE
        -- 存入 '2000-12-12'
        ```
    *   **使用场景：** 生日、纪念日等只需要年月日的场景。

*   #### `DATETIME` - 日期时间 (⭐最常用)
    *   **通俗解释：** 存储年月日时分秒。
    *   **来源/细节：**
        *   格式：`'YYYY-MM-DD HH:MM:SS'` (年-月-日 时:分:秒)。
        *   范围：`'1000-01-01 00:00:00'` 到 `'9999-12-31 23:59:59'`。
        *   占用 $5$ 到 $8$ 个字节 (MySQL 5.6.4+ 使用5字节，之前是8字节)。
    *   **例子：**
        ```sql
        -- 假设 payment_time DATETIME
        -- 存入 '2024-03-15 10:30:55' (记录支付时间)
        -- 假设 log_event_time DATETIME
        -- 存入 '2024-12-18 15:23:40' (记录日志发生时间)
        ```
    *   **使用场景：** 记录事件发生的精确时间，如订单创建时间、用户注册时间、日志时间。**这是最常用的日期时间类型。**

*   #### `TIMESTAMP` - 时间戳
    *   **通俗解释：** 也是存年月日时分秒，但它与时区有关，并且有一个特殊的范围，常用来记录数据的最后修改时间。
    *   **来源/细节：**
        *   存储从 `1970-01-01 00:00:01` UTC 到 `2038-01-19 03:14:07` UTC 之间的时间。
        *   占用 $4$ 个字节。
        *   **特点：**
            *   插入时，如果值是 `NULL` 或未提供，并且该列有 `DEFAULT CURRENT_TIMESTAMP` 或 `ON UPDATE CURRENT_TIMESTAMP` 属性，它会自动设置为当前时间。
            *   存储时会转换为UTC（世界标准时间），检索时会转换回当前会话的时区。这对于多时区应用很有用。
        *   "时间戳" 本意是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。但MySQL的`TIMESTAMP`类型存储的是日期时间格式。
    *   **例子：**
        ```sql
        -- 假设 last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
        -- 当行数据被创建或更新时，这个字段会自动更新为当前时间
        ```
    *   **使用场景：** 记录行的创建时间 (`created_at`) 或最后修改时间 (`updated_at`)。

*   #### `TIME` - 时间
    *   **通俗解释：** 只存储时分秒。
    *   **来源/细节：**
        *   格式：`'HH:MM:SS'`。
        *   范围：`'-838:59:59'` 到 `'838:59:59'` (可以表示时间间隔，不仅仅是一天内的时间)。
        *   占用 $3$ 个字节。
    *   **使用场景：** 存储一天中的某个特定时间，或者时间段的长度。用得相对较少。

*   #### `YEAR` - 年份
    *   **通俗解释：** 只存储年份。
    *   **来源/细节：**
        *   可以存储为2位数或4位数。
        *   `YEAR(4)` 格式 (默认): 范围 `1901` 到 `2155`。
        *   `YEAR(2)` 格式: 范围 `70` (表示1970) 到 `69` (表示2069)。(不推荐使用YEAR(2)因为它有歧义)
        *   占用 $1$ 个字节。
    *   **使用场景：** 单独存储年份，如毕业年份。用得相对较少。

### 1.3.6 二进制类型 (Binary Types)

**一句话概括：** 二进制类型用来存储原始的字节数据，比如图片文件、音频文件或者其他非文本的二进制信息；当数据量很大时，使用`BLOB`系列的类型。

*   用于存储二进制数据，如图片、音频、编译后的代码等。
*   与字符串类型（`CHAR`, `VARCHAR`, `TEXT`）的主要区别在于，二进制字符串存储的是字节序列，而常规字符串存储的是字符序列，并受字符集和排序规则的影响。二进制字符串的比较是基于字节值的。

*   #### `BINARY(M)` - 定长二进制字符串
    *   **通俗解释：** 类似`CHAR(M)`，但是存的是固定长度的字节，不是字符。
    *   **来源/细节：**
        *   `M` 是字节长度，范围 $0$ 到 $255$。
        *   如果存入的数据短于`M`字节，会在右边用 `0x00` (空字节) 补齐。
    *   **使用场景：** 存储固定长度的二进制数据，如MD5哈希值（通常是32个十六进制字符，即16字节的BINARY）。

*   #### `VARBINARY(M)` - 变长二进制字符串
    *   **通俗解释：** 类似`VARCHAR(M)`，但是存的是可变长度的字节。
    *   **来源/细节：**
        *   `M` 是最大字节长度，最大 $65535$。
        *   只占用实际需要的字节数 + 1或2个字节的长度前缀。
    *   **使用场景：** 存储可变长度的二进制数据，但长度通常不会特别大。

*   #### `BLOB` 类型家族 - 二进制大对象 (Binary Large Object)
    *   **通俗解释：** 对应`TEXT`家族，是用来存“大块头”的二进制数据的，比如整个图片文件、视频片段。
    *   **来源/细节：**
        *   `TINYBLOB`: 最大长度 $255$ ($2^8 - 1$) 字节。
        *   `BLOB`: 最大长度 $65,535$ ($2^{16} - 1$) 字节 (约64KB)。
        *   `MEDIUMBLOB`: 最大长度 $16,777,215$ ($2^{24} - 1$) 字节 (约16MB)。
        *   `LONGBLOB`: 最大长度 $4,294,967,295$ ($2^{32} - 1$) 字节 (约4GB)。
    *   **例子：**
        ```sql
        -- 假设 user_avatar BLOB  -- 存储用户头像图片（但不推荐，通常存图片路径）
        -- 假设 small_audio_clip MEDIUMBLOB -- 存储一个小音频片段
        -- 假设 movie_file LONGBLOB -- 存储一个电影文件（非常不推荐这样做）
        ```
    *   **使用场景：** 存储图片、音频、视频等二进制文件。**注意：** 通常不建议将非常大的文件（如高清视频）直接存储在数据库中，因为会显著增加数据库大小、影响备份恢复速度和性能。更常见的做法是文件存储在文件系统或对象存储服务中，数据库中只存储文件的路径或URL。

*   #### `BIT(M)` - 位字段类型 (⭐可巧妙用于布尔值)
    *   **通俗解释：** 存储“位”（bit）数据，一个位只能是0或1。`BIT(1)` 就只能存1个0或者1个1。
    *   **来源/细节：**
        *   `M` 指定位值的数量，范围从 $1$ 到 $64$。如果省略 `M`，默认为 $1$。
        *   `BIT(1)` 表示存储1个比特位。
    *   **巧妙用途 (模拟布尔值):**
        *   当老师说MySQL没有真正的布尔类型时，提到了用 `TINYINT(1)` 或 `VARCHAR(1)`。
        *   `TINYINT(1)`虽然约定0为false，1为true，但它本质上是个1字节的整数，可以存入 $0, 1, 2, ... , 127$ (或 $255$ 如果是unsigned) 等值。虽然非0都当true，但不够“纯粹”。
        *   `VARCHAR(1)` 存 `'0'` 或 `'1'` 字符，也有类似问题，可以存 `'2'`, `'a'` 等。
        *   **`BIT(1)` 的优势：** 它在物理上就只能存储 $0$ 或 $1$。你不能把 $2$ 存入 `BIT(1)` 字段。
            *   占用空间最小 (理论上1 bit，但实际存储可能因对齐等因素占用更多，但概念上是最节省的)。
            *   严格限制了值只能是 $0$ 或 $1$。
    *   **例子：**
        ```sql
        -- 假设 is_active BIT(1)
        -- 插入时:
        -- INSERT INTO ... (is_active) VALUES (b'1'); -- 代表 True (激活)，b''是位值字面量表示法
        -- INSERT INTO ... (is_active) VALUES (b'0'); -- 代表 False (未激活)
        -- 或者直接用数字0和1
        -- INSERT INTO ... (is_active) VALUES (1);
        -- INSERT INTO ... (is_active) VALUES (0);
        ```
    *   **使用场景：** 存储布尔标记（是/否，开/关），或者需要按位操作的标志集合。对于布尔值，`BIT(1)` 是一个存储空间和值域都非常精确的选择。

## 1.4 三、总结

**一句话概括：** 学习和理解MySQL的各种数据类型，就像工匠熟悉自己的工具箱一样，能帮助我们更精确、更高效地设计数据库表结构，为后续的数据操作打下坚实的基础。

这节课我们详细了解了MySQL中常用的数据类型，包括字符串、整数、浮点数、日期时间以及二进制类型。每种类型都有其特定的用途和存储特性。
在下一节课创建表的时候，我们就会用到这些类型名了，所以大家一定要把它们搞清楚，尤其是那些常用的：`VARCHAR`, `INT`, `DECIMAL`, `DATETIME`, `BIT(1)`/`TINYINT(1)`。

花时间理解这些内容是非常值得的，它关系到你数据库设计的合理性、存储效率以及后续数据查询和操作的性能！